#+TITLE: tutorial-de-c
#+AUTHOR: Patricio Martínez
#+EMAIL: maxxcan@disroot.org

* C - Introducción

  Este tutorial es una traducción del tutorial que podemos encontrar en [[https://www.tutorialspoint.com/cprogramming/index.htm][Tutorialspoint]]

* C - Resumen

  C es un lenguaje de propósito general, un lenguaje de alto nivel que fue originalmente desarrollado por *Dennis M. Ritchie* para desarrollar el sistema operativo UNIX en los laboratorios Bell. C fue originalmente implementado para la computadora DEC PDP-11 en 1972. 

  En 1979, Brian Kerninghan y Dennis Ritchie produjeron la primera descripción de C para el público, ahora conocido como el estándar K&R. 

  El sistema operativo UNIX, el compilador de C y esencialmente todas las aplicaciones UNIX han sido escritas en C. C es un lenguaje ampliamente usado como lenguaje profesional por varias razones

  + Fácil de aprender
  + Lenguaje estructurado
  + Produce programas eficientes
  + Puede manejar actividades a bajo nivel
  + Se puede compilar para una amplia variedad de plataformas

** Hechos sobre C 

   + C fue inventado para escribir un sistema operativo llamado UNIX
   + C es un sucesor del lenguaje B el cual fue introducido sobre los tempranos 1970
   + El lenguaje fue formalizado en 1988 por el Instituto Nacional Americano de Estándares (ANSI)
   + El sistema operativo UNIX está totalmente escrito en C
   + A día de hoy C es el lenguaje más usado y popular como Lenguaje de Sistemas
   + Muchos de los estados de arte han sido implementados usando C
   + A día de hoy muchos de los populares Sistemas Operativos Linux o bases de datos como MySQL han sido escritos en C

** Por qué usar C

   C fue inicialmente usado para el trabajo de desarrollo de sistemas, particularmente la programación de sistemas operativos. C fue adoptado como un lenguaje de desarrollo de sistemas porque producía código que corría casi tan rápido como código escrito en lenguaje ensamblador. Algunos ejemplos de uso de C podrían ser - 

   + Sistemas Operativos 
   + Compiladores de Lenguajes
   + Ensambladores
   + Editores de texto
   + Gestores de impresión
   + Controladores de Red
   + Programas modernos
   + Bases de datos
   + Lenguajes interpretados
   + Utilidades

** Programas en C

   Un programa en C puede variar desde 3 líneas a millones de líneas y puede ser escrito en una o más ficheros de texto con la extensión *".c"*; por ejemplo, /hello.c/. Podemos usar "vi", "vim" o cualquier editor de texto para escribir tu programa C en un archivo.

   Este tutorial asume que conoces como editar un fichero de texto y escribir código fuente en un archivo de programa. 

* C - Configurando el entorno

  Si queremos configurar nuestro entorno de para programar en el lenguaje C, necesitamos las dos siguientes herramientas de software en nuestro computador; un Editor y el Compilador de C.

** Editor de texto

   Será usado para escribir nuestro programa. Ejemplos de algunos editores incluyen Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, y vim o vi. 

   El nombre y la versión del editor de texto puede variar en diferentes sistemas operativos. Por ejemplo, Notepad será usado en Windows, y vim o vi puede ser usado en windows y también en Linux o UNIX.

   Los archivos que creemos con el editor de texto son llamados archivos fuente y ellos contienen los códigos fuente. Los archivos fuente para los programas C son típicamente nombrados con la extensión *".c"*. 

   Antes de empezar nuestro programa, tendremos que estar seguro que usamos un editor de texto con el cual tendremos suficiente experiencia para escribir programas, salvarlos, compilarlos y finalmente ejecutarlos.

** El compilador C

   El código fuente escrito en el archivo fuente es la fuente humanamente leíble para nuestro programa. Pero necesita ser "compilado", en lenguaje máquina para que nuestra CPU puede realmente ejecutar el programa. 

   El compilador compila el código fuente en el programa ejecutable final. El compilador más frecuentemente usado y de libre acceso es el compilador de GNU C/C++, en caso distinto tenemos los compiladores de HP o Solaris si tenemos los sistemas operativos respectivos. 

   En la sección siguiente explicaremos como instalar el compilador GNU C/C++ en varios Sistemas Operativos. Mencionamos juntos C/C++ porque el compilador GNU Gcc funciona para ambos lenguajes. 

** Instalación en UNIX/Linux

   Si estás usando *Linux o UNIX*, entonces comprobaremos si GCC está instalado en el sistema introduciendo el siguiente comando  - 

   : $ gcc -v

   Si el compilador  está instalado, entonces imprimirá el siguiente mensaje - 

   #+BEGIN_SRC shell
     Using built-in specs.
     Target: i386-redhat-linux
     Configured with: ../configure --prefix=/user ......
     Thread model: posix
     gcc version 4.1.2 200080704 (Red Hat 4.1.2-46)
   #+END_SRC

   Si GCC no está instalado, entonces tendremos que instalarlo por nosotros mismos usando las detalladas instrucciones disponibles en [[https://gcc.gnu.org/install/][la página de gcc]]. 

   Este tutorial ha sido escrito basado en Linux y todos los ejemplos han sido compilados  en la distribución Cent OS del sistema Linux.

** Instalación en Mac OS

   Si usas un Mac OS X, la forma más sencilla de obtener GCC es descargándose el entorno de desarrollo Xcode desde la página de Apple y seguir las instrucciones. Una vez hayas configurado Xcode, serás capaz de usar el Compilador GNU C/C++.

** Instalación en Windows

   Para instalar GCC en Windows, se necesita instalar MinGW. Para instalar MinGW, es necesario ir a su [[http://www.mingw.org/][página]], y seguir el enlace a su página de descarga.

   Mientras se instala Min GW, al mínimo, se debe instalar gcc-core, gcc-g++, binutils, y el MinGW runtime, pero se podrían instalar más cosas.

   Añadiremos el subdirectorio *bin* de la instalación a la variable *PATH*, así como especificar las herramientas a usar. 

   Después de que la instalación se haya completado, serás capaz de ejecutar gcc, g++, ranlib, diltool y varias otras herramientas de GNU en la línea de Comandos de Windows.

* C - Estructura del programa

  Antes de que estudiemos los bloques básicos del programa C, echemos un ojo la estructura mínima de un programa en C que tomaremos de referencia en los siguientes capítulos. 

** Ejemplo - Hola Mundo - 

   Un programa en C básicamente consiste de las siguientes partes - 

   + Comandos de preprocesado
   + Funciones
   + Variables
   + Declaraciones y expresiones
   + Comentarios

   Echemos un vistazo a un simple código que puede dibujar las palabras "Hola Mundo" -  

   #+BEGIN_SRC C
     #include <stdio.h>

     int main() {
       /* mi primer programa en C*/
       printf("Hola, Mundo! \n");

       return 0
	 }
   #+END_SRC

   Veamos las  distintas partes del programa - 

   * La primera línea del programa *#include<stdio.h>* es  un comando preprocesador, el cual le dice al compilador de C incluir stdio.h antes de empezar a compilar. 

   * La siguiente línea /main()/ es la función principal donde la ejecución del programa comienza.

   * la siguiente línea /*..*/ será ignorada por el compilador y se usará para poner comentarios en el programa. Tales líneas son llamadas  comentarios en el programa.

   * La próxima línea /printf(...)/ es otra función disponible en C la cual causa que el mensaje "Hola Mundo!" sea mostrado en la pantalla. 

   * La siguiente línea *return 0*; termina la función main() y devuelve el valor 0.

** Compilando y ejecutando el programa C

   Vamos a ver cómo salvar el código fuente en un archivo, como compilarlo y ejecutarlo. Siguiendo unos simples pasos - 

   * Abrir el editor de texto y añadir el código antes mencionado

   * Salvar el archivo como hola.c

   * Abrir una consola de comandos e ir al directorio donde se ha salvado el archivo

   * Escribir gcc hola.c y presionar intro para compilar el código

   * si no hay errores en el código, la línea de comandos generará un fichero ejecutable a.out

   * Ahora, escribimos a.out para ejecutar el programa

   * Veremos la salida "Hola Mundo" dibujado en la pantalla

   : $ gcc hello.c
   : $ ./a.out
   : Hola Mundo!

* C - Sintáxis básica 

  Hemos visto la estructura de un programa C, así que será fácil entender otros bloques de construcción del lenguaje C. 

** Tokens en C

   Un programa en C consiste en varios tokens y un token puede ser una palabra clave, un identificador, una constante, una cadena de texto, o un símbolo. Por ejemplo, la siguiente declaración consiste de cinco tokens. - 

   #+BEGIN_SRC C
     printf("Hola Mundo! \n");
   #+END_SRC

   Los tokens individuales son - 

   #+BEGIN_SRC C
     printf
     (
      "Hola Mundo! \n"
      )
     ;
   #+END_SRC

** Punto y coma

   En un programa C, el punto y coma es una declaración de fin. Eso es, cada declaración individual debe ser terminada con una punto y coma. Ello indica el final de una entidad lógica.

   Aquí vemos dos declaraciones diferentes - 

   #+BEGIN_SRC C
     printf("Hola, Mundo! \n");
     return 0;
   #+END_SRC

** Comentarios

   Los comentarios son como textos de ayuda  en el programa y son ignorados por el compilador. Empiezan con /* y terminan con */ tal como se muestra a continuación.

   #+BEGIN_SRC C
     /* mi primer programa en C */
   #+END_SRC

   No podemos tener comentarios dentro de comentarios y no pueden ocurrir con una cadena de caracteres.

** Identificadores 

   Un identificador en C es un nombre usado para identificar una variable, función, o cualquier otro item definido por el usuario. Un identificador empiezar con unal letra de la A a la Z, mayúsculo o minúscula o un guíon bajo '_' seguido por cero o más letras, guiones bajos y dígitos (de 0 a 9).

   C no permite caracteres de puntuación tales como @, $, y % en los identificadores. C es sensible a mayúsculas y minúsculas. Por lo que, Manpower y manpower son dos identificadores distintos en C. Aquí hay algunos ejemplos de identificadores aceptables - 

   : mohd  zara abc move_name a_123
   : myname50 _temp j a23b9 retVal

** Palabras clave

   Las siguiente lista muestra las palabras reservadas en C. Esas palabras reservadas no deben ser usadas como constantes o variables o cualquier nombre de identificador. 


   | auto     | else   | long     | switch   |
   | break    | enum   | register | typedef  |
   | case     | extern | return   | union    |
   | char     | float  | short    | unsigned |
   | const    | for    | signed   | void     |
   | continue | goto   | sizeof   | volatile |
   | default  | if     | static   | while    |
   | do       | int    | struct   | _Packed  |
   | double   |        |          |          |


** Espacios en blanco en C

   Una línea conteniendo solo espacios en blanco, posiblemente con un comentario, es conocida como línea en blanco y el compilador de C la ignora.

   Los espacios en blanco es el termino usado en C para describir espacio en blanco, tabulador, carácter de nueva línea y comentarios. Los espacios en blanco separa una parte de una declaración de otra y habilita al compilador a identificar donde un elemento en una declaración, tal como entero, finaliza y comienza el siguiente elemento.

   Por lo tanto, en la siguiente declaración - 

   : int edad;

   debe haber al menos un espacio en blanco (normalmente un espacio) entre int y edad para que el compilador sea capaz de distinguirlos. Por otro lado, en la siguiente declaración - 

   : frutas = manzanas + naranjas; //  obtener el total de frutas

   Los espacios en blanco no son necesarios entre fruta y el símbolo =, o entre el = y las manzanas, además somos libres de incluir alguno más si deseamos mayor legibilidad. 

* C - Tipos de datos 

  Los tipos de datos en C se refieren a un extensivo sistema usado para declarar variables o funciones de diferentes tipos. El tipo de variable determina cuanto espacio ocupará en memoria y como será el patrón de bits guardados interpretados. 

  Los tipos en C puede ser clasificados de las siguiente manera - 

  | Sr.No. | Tipos            | Descripción                                                                                             |
  |      1 | Tipos básicos    | Son tipos aritméticos y clasificados en: enteros y comas flotante.                                      |
  |      2 | Tipos enumerados | También son tipos aritméticos y son usados para definir variables que solo pueden ser valores discretos |
  |      3 | El tipo vacío    | El tipo vacío especifica que no tienen ningún valor                                                     |
  |      4 | Tipos derivados  | Incluyen punteros, arrays, estructuras, uniones y funciones                                             |


  Los arrays y las estructuras son referidos colectivamente como tipos agregados. Los tipos funciones especifican un tipo que devuelve la función. Veremos los tipos básicos en la siguiente sección, donde como otros tipos serán cubiertos en sucesivos capítulos. 

** Tipos Enteros

   La siguiente tabla proporciona los detalles de los tipos enteros estándar con sus tamaños y rangos de valor - 

   | Tipo           | Tamaño      | Rango                                             |
   |----------------+-------------+---------------------------------------------------|
   | char           | 1 byte      | -128 a 127 o 0 a 255                              |
   | unsigned char  | 1 byte      | 0 a 255                                           |
   | signed char    | 1 byte      | -128 a 127                                        |
   | int            | 2 o 4 bytes | -32,768 a 32,768 o -2,147,483,648 a 2,147,483,647 |
   | unsigned it    | 2 o 4 bytes | 0 a 65,535 o 0 a 4,294,967,285                    |
   | short          | 2 bytes     | -32,768 a 32,767                                  |
   | unsigned short | 2 bytes     | 0 a 65,535                                        |
   | long           | 8 bytes     | -9223372036854775808 a 9223372036854775807        |
   | unsigned long  | 8 bytes     | 0 a 18446744073709551815                          |


   Para obtener exactamente el tamaño de un tipo de variable en una plataforma en particular, podemos usar el operador *sizeof*. La expresión /sizeof(type)/ produce el tamaño del objeto o tipo en bytes. Veremos un ejemplo para obtener el tamaño de varios tipos en una computadora usando diferentes constantes definidos en el archivo limits.h


*** Demo 

    #+BEGIN_SRC C
      #include <stdio.h>
      #include <stdlib.h>
      #include <limits.h>
      #include <float.h>

      int main(int argc, char** argv) {

	printf("CHAR_BIT    :    %d\n", CHAR_BIT);
	printf("CHAR_MAX    :    %d\n", CHAR_MAX);
	printf("CHAR_MIN    :    %d\n", CHAR_MIN);
	printf("INT_MAX     :    %d\n", INT_MAX);
	printf("INT_MIN     :    %d\n", INT_MIN);
	printf("LONG_MAX    :    %ld\n", (long) LONG_MAX);
	printf("LONG_MIN    :    %ld\n", (long) LONG_MIN);
	printf("SCHAR_MAX   :    %d\n", SCHAR_MAX);
	printf("SCHAR_MIN   :    %d\n", SCHAR_MIN);
	printf("SHRT_MAX    :    %d\n", SHRT_MAX);
	printf("SHRT_MIN    :    %d\n", SHRT_MIN);
	printf("UCHART_MAX  :    %d\n", UCHART_MAX);
	printf("UINT_MAX    :    %u\n", (unsigned int) UINT_MAX);
	printf("ULONG_MAX   :    %lu\n", (unsigned long) ULONG_MAX);
	printf("USHRT_MAX   :    %d\n", (unsigned short) USHRT_MAX);

	return 0;
      }
    #+END_SRC

    Cuando compilemos y ejecutemos el programa, producirá el siguiente resultado en Linux - 

    #+BEGIN_SRC 
CHAR_BIT    :   8
CHAR_MAX    :   127
CHAR_MIN    :   -128
INT_MAX     :   2147483647
INT_MIN     :   -2147483648
LONG_MAX    :   9223372036854775807
LONG_MIN    :   -9223372036854775808
SCHAR_MAX   :   127
SCHAR_MIN   :   -128
SHRT_MAX    :   32767
SHRT_MIN    :   -32768
UCHAR_MAX   :   255
UINT_MAX    :   4294967295
ULONG_MAX   :   18446744073709551615
USHRT_MAX   :   65535
    #+END_SRC


** Tipos Coma flotante

   La siguiente tabla proporciona los detalles de los tipos comas flotante estándar  con sus tamaños y los valores de sus rangos y su precisión - 

   | Tipo        | Tamaño  | Rango                 | Precisión     |
   |-------------+---------+-----------------------+---------------|
   | float       | 4 byte  | 1.2E-38 a 3.4E+38     | 6 decimales   |
   | double      | 8 byte  | 2.3E-308 a 1.7E+308   | 15 decimales  |
   | long double | 10 byte | 3.4E-4932 a 1.1E+4932 | 19  decimales |

   El fichero de cabecera float.h  define las macros que nos permite usar esas variables y otros detalles sobre la representación en binario de los números reales en nuestros programas. El siguiente ejemplo dibuja el espacio de guardado que toma los tipo coma flotante y su rango de valores. 

   --Demo 

   #+BEGIN_SRC C
     #include <stdio.h>
     #include <stdlib.h>
     #include <limits.h> 
     #include <float.h>

     int main(int argc, char*** argv) {

       printf("Espacio para el punto flotante: %d \n", sizeof(float));
       printf("FLT_MAX     :   %g\n", (float) FLT_MAX);
       printf("FLT_MIN     :   %g\n", (float) FLT_MIN);
       printf("-FLT_MAX    :   %g\n", (float) -FLT_MAX);
       printf("-FLT_MIN    :   %g\n", (float) -FLT_MIN);
       printf("DBL_MAX     :   %g\n", (double) DBL_MAX);
       printf("DBL_MIN     :   %g\n", (double) DBL_MIN);
       printf("-DBL_MAX     :  %g\n", (double) -DBL_MAX);
       printf("Valor de precisión: %d\n", FLT_DIG );

       return 0;

     }
   #+END_SRC

   Cuando ejecutemos el programa obtendremos el siguiente resultado en Linux - 


   : Espacio para el punto flotante: 4 
   : FLT_MAX      :   3.40282e+38
   : FLT_MIN      :   1.17549e-38
   : -FLT_MAX     :   -3.40282e+38
   : -FLT_MIN     :   -1.17549e-38
   : DBL_MAX      :   1.79769e+308
   : DBL_MIN      :   2.22507e-308
   : -DBL_MAX     :  -1.79769e+308
   : Valor de precisión: 6


** El tipo void

   El tipo void especifica que ningún valor está disponible. Es usado en tres tipos de situaciones - 

   * La función devuelve void. 
     Hay varias funciones en C las cuales no devuelven ningún valor o que podemos decir que devuelvan void. Una función con ningún valor de retorno tiene el tipo de retorno como void. Por ejemplo *void exit(int status);* 

   * Argumento de función como void. 
   Hay varias funciones en C las cuales no aceptan ningún parámetro. Una función sin ningún parámetro puede aceptar un void. Por ejemplo *int rand(void);* 

   * Punteros a void. 
   Un puntero de tipo void representa la dirección de un objeto, pero no su tipo. Por ejemplo, una función de asignación *void \*malloc( size_t size);* devuelve un puntero a void el cual puede ser referenciado a cualquier tipo de dato.
* C - Variables

  Una variable no es nada más que un nombre que se le da a un área de almacenamiento que nuestro programa puede manipular. Cada variable en C tiene un tipo específico, el cual determina el tamaño la capa de la variable de memoria; el ragon de valores que puede ser guardado en esa memoria; y el conjunto de operaciones que pueden ser aplicadas a la variable.

  El nombre de una variable puede estar compuesto de letras, dígitos, y guiones bajos. Deben empezar por una letra o un guión bajo. C distingue entre letras mayúsculas y minúsculas ya que C es case-sensitivo. Basandose en los tipos básicos explicados en el capítulo anterior, veremos los siguientes tipos de variables. 

  | Nº | Tipo     | Descripción                                          |
  |----+----------+------------------------------------------------------|
  |  1 | Caracter | Típicamente un octeto (un byte). Es un tipo entero   |
  |  2 | Entero   | El tipo más natural de tamaño entero para la máquina |
  |  3 | Flotante | Un simple precisión flotante Valor                   |
  |  4 | double   | Una doble precisión flotante valor                   |
  |  5 | void     | Representa la ausencia de tipo                       |

  El lenguaje C también permite definir otros varios tipos de variables, las cuales serán cubiertas en los subsecuentes capítulos como Enumeración, Punteros, Arrays, Estructuras, Uniones, etc. Por este capítulo, vamos a estudiar solo los tipos básicos.

** Definición de variable en C 

   Una definición de variable le dice al compilador donde y cuanto de grande es el almacenamiento por crear para la variable. La definición de variable especifica un tipo de dato y contiene una lista de uno o más variables de esos tipos, como sigue -- 

   : tipo lista_de_variables;

   Aquí *tipo* debe ser un dato C válido incluyendo char, w_char, int, float, double, bool, o cualquier tipo de objeto definido por el usuario; una *lista_de_variables* que consistirá en uno o más nombres identificadores separados por comas. Algunas declaraciones válidas son mostradas aquí - 


   #+BEGIN_SRC C
     int i, j, k;
     char c, ch;
     float f, salario;
     double d;

   #+END_SRC

   En la primera línea declaramos las variables i,j y k; las cuales le damos las instrucciones al compilador el crear variables llamadas i,j y k del tipo entero.

   Las variables pueden ser inicializadas (asignándoles un valor inicial) en esa declaración.  La inicialización consiste en un signo igual seguido de una expresión constante tal como sigue -

   : tipo nombre_variable = valor;

   Algunos ejemplos serían --

   #+BEGIN_SRC C

     extern int d = 3, f = 5;  // declaración de d y f.
     int d = 3, f = 5;  // definición e inicialización de d y f.
     byte z = 22;   // definición e inicialización de z.
     char x = 'x';   // la variable x tiene el valor 'x'.

   #+END_SRC

   Para definir sin inicializar: las variables con almacenamiento de duración estático son implícitamente inicializados con NULL (todos los bytes tienen el valor 0); el valor inicial de todos las otras variables son indefinidos.

** Declaración de variables en C 

   Una declaración de variable proporciona garantía al compilador de que existe una variable con el tipo dado y el nombre así que el compilador puede proceder más rápido a la compilación sin requerir el completo detalle sobre la variable. Una definición de variable tiene su significado en el momento de compilación solo, el compilador necesita una definición de variable en el momento del linkado del programa. 

   Una declaración de variable es muy útil cuando usamos múltiples archivos y definimos nuestra variable en uno de los archivos el cual debe ser accesible en el momento del linkado de el programa. Usaremos la palabra clave *extern* para declarar una variable en un lugar. Además podemos declarar una variable muchas veces en nuestro programa C, ello puede ser definido solo una vez en un archivo, una función o un bloque de código.

*** Ejemplo   

    Veamos el siguiente ejemplo, donde las variables han sido declaradas al principio, pero han sido definidas e inicializadas dentro de la función principal - 

    #+BEGIN_SRC C
      #inclue <stdio.h>

      // declaración de variables
      extern int a, b;
      extern int c;
      extern float f;

      int main() {

	/* definición de variables */
	int a, b;
	int c;
	float f;

	/* verdadera inicialización */
	a = 10;
	b = 20;

	c = a + b;
	printf("el valor de c : %d \n", c);

	f = 70.0/3.0;
	printf("el valor de f : %f \n", f);

	return 0;

      }

    #+END_SRC

    Cuando compilemos y ejecutemos el código anterior, se producirá el siguiente resultado - 

    : el valor de c : 30
    : el valor de f : 23.3333334

    El mismo concepto aplicado en las declaraciones de funciones donde proveeremos el nombre de una función al mismo tiempo que su declaración y su verdadera definición puede ser dada en cualquier sitio más. Por ejemplo - 

    #+BEGIN_SRC C
      // declaración de función
      int func();

      int main() {

	//llamada a la función
	int i = func()
	  }

      //definición de función
      int func(){
	return 0;
      }

    #+END_SRC

    Valor-L y Valor-R en C 

    Hay dos tipos de expresiones en C - 

    - l-valor - Las expresiones que se refieren a la posición de memoria son llamadas expresiones "l-valor". Una l-valor puede aparecer tanto como mano izquierda o mano derecha de una asignación.

    - r-valor - El termino r-valor se refiere a un valor de datos que es guardado en una dirección de memoria. Un r-valor es una expresión que no puede tener un valor asignado a ello lo cual significa que un r-valor puede aparecer a la derecha pero no a la izquierda de una asignación.

    Las variables son l-valores y así pueden aparecer en el lado izquierdo de una asignación. Los literales numéricos son r-valores y así ellos no deben ser asignados y no pueden aparecer en el lado izquierdo de una asignación. Echemos un vistazo a una declaración válida y a otra inválida.

    : int g = 20; //declaración válida
    : 10 = 20 // declaración inválida; generará un error en tiempo de compilación

* C - Constantes y literales 


  Constantes se refire a valores fijos que el programa no puede alterar durante su ejecución. Esos valores fijos son también llamados *literales*. 

  Las constantes pueden ser cualquier tipo de dato básico como una /constante entera, una punto flotante, cadena de caracteres o un carácter/. Hay enumeraciones constantes también. 

  Las constantes son tratadas como variables normales excepto que sus valores no pueden sere modificados después de su definición. 

** Literales enteros 

   Un literal entero puede ser una constante decimal, octal o hexadecimal. Un prefijo especifica la base o la base: 0x o 0X para hexadecimal, 0 para octal y nada para decimal. 

   Un literal entero puede tambijén tener un sufijo que es una combinación de U y L, para sin signo o largo, respectivamente. El sufijo puede ser uppercase o lowercase y puede estar en cualquier orden. 

   Aquí hay algunos ejemplos de literales enteros - 

   #+BEGIN_SRC C
     3.14159       /* Legal */
     314159E-5L    /* Legal */
     510E          /* Ilegal: exponente incompleto */
     210f          /* Ilegal: sin decimal o sin exponente */
     .e55          /* Ilegal: sin fracción o entero */
   #+END_SRC

** Constantes carácter 

   Los literales carácter son encerrados con comillas simples, ejemplo, 'x' y pueden ser guardadas en una variable simple de tipo *char*. 

   Un literal carácter puede ser un carácter plano (ejemplo, 'x'), una secuencia de escape (ejemplo, '\t') o un carácter universal (ejemplo, '\u02C0).

   hay ciertos caracteres en C que representan un significado especial cuando son precedidos por una barra invertido, como una nueva linea (\n) o un tabulador (\t). 

*** Lista de secuencias de escape 

    | Secuencia de escape | Significado                         |
    |---------------------+-------------------------------------|
    | \\                  | carácter \                          |
    | \'                  | carácter '                          |
    | \"                  | carácter "                          |
    | \?                  | carácter ?                          |
    | \a                  | alerta o campana                    |
    | \b                  | espacio para atrás                  |
    | \f                  | Alimentador de informe              |
    | \n                  | nueva línea                         |
    | \r                  | salto de carro                      |
    | \t                  | tabulador horizontal                |
    | \v                  | tabulador vertical                  |
    | \ooo                | número octal de 1 a 3 dígitos       |
    | \xhh                | número hexadecimal de 1 a 3 dígitos |

    En el siguiente ejemplo mostraremos unas pocas secuencias de escape 

    --demo 

    #+BEGIN_SRC C 
      #include <stdio.h>

      int main() {
	printf("Hola\tMundo\n\n");

	return 0
	  }
    #+END_SRC

    Cuando ejecutemos el código y lo ejecutemos, producirá el siguiente resultado --

    : Hola Mundo 

** Literales cadenas de caracteres


   Los literales cadena de texto o constantes son encerrados en dobles comillas "". Una cadena de texto contiene caracteres que son similares a los caracteres literales: caracteres planos, secuencias de escape y caracteres universales. 

   Vamos a ver algunos ejemplos de cadenad de texto literales. Estas tres formas son idénticas. 

   #+BEGIN_SRC C
     "hola, señor"

     "hola, \
     señor"

     "hola, " "s" "eñor"
   #+END_SRC

** Definiendo constantes

   Hay dos simples formas en C de definir constantes - 

   * Usando el preprocesador *#define* 

   * Usando la palabra clave *const* 

*** El preprocesador #define 

    Dado la siguiente forma de usar #define para definir una constante - 

    #+BEGIN_SRC C
      #define identificador valor
    #+END_SRC

    El siguiente ejemplo lo explica en detalle 

    #+BEGIN_SRC C

      #include <stdio.h>

      #define LENGTH 10
      #define WIDTH 5
      #define NEWLINE '\n'

      int main(){

	int area;

	area = LENGTH * WIDTH;
	printf("el valor del area es: %d", area);
	printf("%c", NEWLINE)

	  return 0;
      }

    #+END_SRC

    Cuando el código anterior es compilado y ejecutado, producirá el siguiente resultado. 

    : el valor del area es: 50

***  La palabra clave const

    Podemos usar el prefijo *const* para declarar constantes con un tipo específico de la siguiente manera - 

    : const tipo variable = valor;

    El siguiente ejemplo lo explica en detalle - 

    #+BEGIN_SRC C

      #include <stdio.h>

      int main(){
	const int LENGTH = 10;
	const int  WIDTH = 5;
	const char NEWLINE = '\n';
	int area;

	area = LENGTH * WIDTH;
	printf("el valor del area es: %d", area);
	printf("%c", NEWLINE);

	return 0;
      }

    #+END_SRC


    El código anterior una vez compilado y ejecutado producirá el siguiente resultado - 

    : el valor del area es : 50

    Es una practica de buen programador definir las constantes en mayúsculas 

* C - Clases de almacenamiento

  Una clase de almacenamiento define el ámbito (visibilidad) y tiempo de vida de una variable y/o función en un programa de C. Preceden el tipo que modifican. Hay cuatro diferentes clases de almacenamiento en C 

  * auto

  * register

  * static

  * extern 

** La clase de almacenamiento auto 

   La clase de almacenamiento auto es la clase por defecto para todas la variables locales. 

   #+BEGIN_SRC C
     {
       int mount;
       auto in month;
     }
   #+END_SRC

   El ejemplo anterior define dos variables con la misma clase de almacenamiento. Solo se puede usar dentro de funciones, es decir, variables locales. 

** La clase de almacenamiento register 

   La clase de almacenamiento *register* es usado para definir variables locales que podŕian ser guardadas en un registro en vez de en RAM. Esto significa que la variable tiene un tamaño máximo igual al tamaño del registro (normalmente una palabra) y no puede tener el operador unario '&' aplicado a él (como no tiene una dirección de memoria).

   #+BEGIN_SRC C
     {
       register int kilómetros;
     }
   #+END_SRC

   Register solo debería ser usado para variables que requiere un acceso rápido tales como contares. Esto podría ser también que definir un 'registro' no significa que la variable vaya a ser guardada en un registro. Esto significa que podría ser guardado en un registro dependiendo del hardware y las restricciones de la implementación.

** La clase de almacenamiento static 

   La clase de almacenamiento *static* le da instrucciones al compilador de mantener una variable local en existencia durante el tiempo de vida del programa en vez de crear y destruir la cada vez que se sale o entra del ámbito. Además, haciendo variables locales estáticas les permiten mantener sus valores entre las llamadas a funciones.

   El modificador 'static' puede también ser aplicado a variables globales. Cuando se hace esto, causa que el ámbito de la variable sea restrictiva al archivo en el que se ha declarado. 

   En programación C, cuando *static* es usado en una variable global, causa solo una copia de el miembro que será compartido por todos los objetos de su clase. 

*** Demo 

    #+BEGIN_SRC C

      #include <stdio.h>

      /* declaracion de funciones */
      void function(void);

      static int conteo = 5; /* variable global */

      main(){
	while(count--){
	  func();
	}

	return 0;
      }

      /* definicion de funciones */
      void func( void ) {

	static int i = 5; /* variable local static */
	i++;

	printf("i es %d y conteo es %d\n ", i, conteo);
      }

    #+END_SRC


    Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado - 

    #+BEGIN_SRC C
      i es 6 y conteo es 4
      i es 7 y conteo es 3
      i es 8 y conteo es 2
      i es 9 y conteo es 1
      i es 10 y conteo es 0

    #+END_SRC

** La clase de almacenamiento extern 


   La clase de almacenamiento *extern* es usada para dar una referencia de una variable global que es visible para todos los archivos del programa. Cuando usamos 'extern', la variable no puede ser inicializada sin embargo, esto apunta el nombre de la variable a una dirección de memoria que ha sido previamente definida. 

   Cuando tenemos múltiples archivos y definimos una variable o función global, la cual es también usada en otros archivos, entonces /extern/ será usado en otro archivo para definir la referencia de la vairable o función definida. Para entender esto, /extern/ es usado para declara una variable o función global en otro archivo. 

   El modificador /extern/ es muy comúnmente usado cuando hay dos o más archivos compartiendo las mismas funciones o variables globales como se ha explicado anteriormente. 

   *Primer fichero: main.c* 

   #+BEGIN_SRC C

     #include <stdio.h>

     int conteo;
     extern void write_extern();

     main() {
       conteo = 5;
       write_extern();
     }

   #+END_SRC

   *Segundo fichero: support.c* 

   #+BEGIN_SRC C

     #include <stdio.h>

     extern int conteo;

     void write_extern(void) {
       printf("conteo es %d\n", conteo);
     }

   #+END_SRC

   Aquí /extern/, está siendo usado para declarar /conteo/ en el segundo archivo, donde tiene su definición en el primer archivo, main.c. Ahora, compila esos dos archivos como sigue -- 

   : $ gcc main.c support.c

   Esto producirá el programa ejecutable *a.out*. Cuando este programa sea ejecutado, producirá el siguiente resultado - 

   : conteo es 5

* C - Operadores 

  Un operardor es un símbolo que le dice al compilador como realizar algunas funciones específicas matemáticas o lógicas. El lenguaje C es rico en operadores y proporciona los siguientes tipos - 

  * Operadores Aritméticos

  * Operadores Relacionales

  * Operadores Lógicos 

  * Operadores a nivel de Bits

  * Operadores de Asignación

  * Operadores varios 

  Veremos en este capítulo la forma en la que cada operador funciona. 

** Operadores Aritméticos 

   La siguiente tabla  muestra todos los operadores aritméticos soportados por C. Asumimos la variable A guarda 10 y B guarda 20, entonces - 


   | Operador | Descripción                            | Ejemplo      |
   |----------+----------------------------------------+--------------|
   | +        | Suma dos operandos                     | A + B = 30   |
   | -        | Resta el segundo al primero            | A - B = -10  |
   | \*       | Multiplica ambos operandos             | A \* B = 200 |
   | \/       | Divide el numerador por el denominador | B\/A = 2     |
   | %        | Modulo operador                        | B % A = 0    |
   | ++       | Incrementa por uno                     | A++ = 11     |
   | --       | Decrementa por uno                     | A-- = 9      |

*** Ejemplo 

    Veamos el siguiente ejemplo 

    #+BEGIN_SRC C

      #include <stdio.h>

      main() {

	int a = 21;
	int b = 10;
	int c ;

	c = a + b;
	printf("Línea 1 - El valor de c es %d\n", c);

	c = a - b;
	printf("Línea 2 - El valor de c es %d\n", c);

	c = a * b;
	printf("Línea 3 - El valor de c es %d\n", c);

	c = a / b;
	printf("Línea 4 - El valor de c es %d\n", c);

	c = a  % b;
	printf("Línea 5 - El valor de c es %d\n", c);

	c = a++;
	printf("Línea 6 - El valor de c es %d\n", c);

	c = a--;
	printf("Línea 7 - El valor de c es %d\n", c);

      }

    #+END_SRC

    #+BEGIN_SRC C
      Línea 1  - El valor de c es 31
      Línea 2  - El valor de c es 11
      Línea 3  - El valor de c es 210
      Línea 4  - El valor de c es 2
      Línea 5  - El valor de c es 1
      Línea 6  - El valor de c es 21
      Línea 7  - El valor de c es 22
    #+END_SRC

** Operadores Relacionales 

   La siguiente tabla muestra todos los operadores relacionales soportados por C. Asumimos que A es 10 y B es 20, entonces -- 

   | Operador | Descripción                                            | Ejemplo              |
   |----------+--------------------------------------------------------+----------------------|
   | \==      | Comprueba si dos operadores son iguales                | (A\==B) no es cierto |
   | \!=      | Compruebas si dos operadores no son iguales            | (A\!=B) es cierto    |
   | >        | Comprueba si un operador (izqda) es mayor que el otro  | (A>B) no es cierto   |
   | <        | Comprueba si un operador (izqda) es menor que el otro  | (A<B) es cierto      |
   | >=       | Comprueba si un operador es mayor o igual que el otro  | (A>=B) no es cierto  |
   | <=       | Compruebas si un operador es menor o igual que el otro | (A<=B) es cierto     |



*** Ejemplo 

    En el siguiente ejemplo entenderemos todos los operadores relacionales en C - 

    #+BEGIN_SRC C

      #include <stdio.h>

      main(){

	int a = 20;
	int b = 10;
	int c ;

	if (a == b) {
	  printf("A es igual a B\n");
	} else {
	  printf("A no es igual a B\n");
	}

	if (a < b) {
	  printf("A es menor que B\n");
	} else {
	  printf("A no es menor que B\n");
	}

	if (a > b) {
	  printf("A es mayor que B\n");
	}else {
	  printf("A no es mayor que B\n");
	}

	/* cambiaremos los valores de a y b */

	a = 5;
	b = 20;

	if (a <= b) {
	  printf("A es al menos menor o igual que B\n");
	}

	if (b >= a) {
	  printf("A es al menos mayor o igual que B");
	}
      }


    #+END_SRC


    Cuando compilemos y ejecutemos el siguiente programa, producirá el siguiente resultado - 

    : A no es igual a B
    : A no es menor que B
    : A es mayor que B
    : A es al menos menor o igual que B
    : B es al menos mayor o igual que B



** Operadores lógicos 

   La siguiente tabla muestra todos los operadores lógicos soportados por C. Asumimos que A es 1 y B es 0, entonces - 

   | Operador | Descripción                                                                         | Ejemplo           |
   | &&       | Llamado AND, si los dos operadores son no cero,entonces la condición es verdadera   | (A&&B) es falso   |
   | ¦¦       | Llamado OR, si los cualquier operador es no cero,entonces la condición es verdadera | (AB) es verdadero |
   | \!       | Llamado NOT. Es usado para revertir el estado lógico de su operador.                |                   |


*** Ejemplo 

    Veremos el siguiente ejemplo para intentar entender todos los operadores lógicos en C -- 

    #+BEGIN_SRC C

      #include <stdio.h>

      main(){

	int a = 5;
	int b = 20;
	int c ;

	if (a && b) {
	  printf("La condición es verdadera\n");
	}

	if (a || b) {
	  printf("La condición es verdadera\n");
	}

	/* vamos a cambiar los valores de a y b */
	a = 0;
	b = 10;

	if (a && b) {
	  printf("La condición es verdadera\n");
	} else {
	  printf("La condición no es verdadera\n");
	}

	if (!(a && b) ) {
	  pirntf("La condición es verdadera\n")
	    }
      }

    #+END_SRC


    Cuando compilemos  y ejecutemos el programa anterior, tendremos el siguiente resultado -- 

    : La condición es verdadera
    : La condición es verdadera 
    : La condición no es verdadera
    : La condición es verdadera 

** Operadores a nivel de bits

   Los operadores a nivel de bits funcionan sobre bits y producen operaciones bit a bit. Las verdaderas tablas para &, | y ^ son las siguientes -- 

   | p | q | p&q | p¦q | p^q |
   | 0 | 0 |   0 |   0 |   0 |
   | 0 | 1 |   0 |   1 |   1 |
   | 1 | 1 |   1 |   1 |   0 |
   | 1 | 0 |   0 |   1 |   1 |


   Si asumimos que A = 60 y B = 13 en formato binario, entonces -- 

   A = 0011 1100
   B = 0000 1101

   --------------

   A&B = 0000 1100
   A|B = 0011 1101

   A^B = 0011 0001
   ~A = 1100 0011

   La siguiente tabla listas los operadores soportados por C. Asumimos que A es 60 y B es 13, entonces -- 

   | Operador | descripción                                                   | Ejemplo                 |
   |----------+---------------------------------------------------------------+-------------------------|
   | &        | Binario AND copia 1 bit si existe en ambos operadores         | (A&B) = 12, 0000 1100   |
   | ¦        | Binario OR copia 1 bit si existe en cualquier operador        | (A¦B) = 61, 0011 1101   |
   | \^       | Binario XOR copia 1 bit si está en uno pero no en ambos       | (A\^B) = 49, 0011 0001  |
   | ~        | Binario 1 complemento tiene el efecto de invertir bits        | (~A) =  1100 0011       |
   | <<       | Binario desplazamiento izquierda. Mueve un valor a la izqda   | A << 2 = 240 1111 0000  |
   | >>       | Binario desplazamiento a la derecha. Mueve un valor a la dcha | A >> 2 = 151, 0000 1111 |



*** Ejemplo 

    Vamos a probar el siguiente ejemplo para entender todos los operadores a nivel de bits de C --

    #+BEGIN_SRC C

      #include <stdio.h>

      main(){

	unsigned int a = 60; /* 60 = 0011 1100 */
	unsigned int b = 13; /* 13 = 0000 1101 */
	int c = 0;

	c = a & b;  /* 12 = 0000 1100 */
	printf("El valor de c es %d\n", c); 

	c = a | b; /* 61 = 0011 1101 */
	printf("El valor de c es %d\n", c);

	c = a ^ b;  /* 49 = 0011 0001 */
	printf("El valor de c es %d\n", c);

	c = ~a; /* 61 = 1100 0011 */
	printf("El valor de c es %d\n", c);

	c = a << 2;  /* 240 = 1111 0000 */
	printf("El valor de c es %d\n", c);

	c = a >> 2; /* 15 = 0000 1111 */
	printf("El valor de c es %d\n", c);
      }


    #+END_SRC


    Cuando compilemos y ejecutemos el programa este producirá el siguiente resultado --- 

    : El valor de c es 12
    : El valor de c es 61
    : El valor de c es 49
    : El valor de c es -61
    : El valor de c es 240
    : El valor de c es 15

** Operadores de asignación 

   La siguiente tabla lista todos los operaciones de asignación que soporte C -- 

   | Operador | Descripción                       | Ejemplo              |
   |----------+-----------------------------------+----------------------|
   | \=       | Operador simple de asignación     | C = A + B. A + B = C |
   | +=       | Añadimos y asignamos              | C += A. C = C + A    |
   | -=       | Sustraemos y asignamos            | C -= A. C = C - A    |
   | *=       | Multiplicamos y asignamos         | C *= A. C = C * A    |
   | \/=      | Dividimos y asignamos             | C \/= A. C = C / A   |
   | %=       | Modulo y asignación               | C %= A. C = C % A    |
   | <<=      | Desplazamiento y asignación izqda | C <<= 2. C = C << 2  |
   | >>=      | Desplazamiento y asignación dcha  | C >>= 2. C = C >> 2  |
   | &=       | AND Bit y asignación              | C &= 2. C = C & 2    |
   | \^=      | Exclusive OR Bit y asignación     | C ^= 2. C = C ^ 2    |
   | ¦=       | Inclusive OR Bit y asignación     | C ¦= 2. C = C ¦ 2    |

*** Ejemplo 

    Veamos el siguiente ejemplo para entender todos los operadores de asignación de C -- 

    #+BEGIN_SRC C

      #include <stdio.h>

      main() {

	int a = 21;
	int c ;

	c = a;
	printf("Operador =. Valor de c = %d\n", c);

	c += a;
	printf("Operador +=. Valor de c = %d\n", c);

	c -= a;
	printf("Operador -=. Valor de c = %d\n", c);

	c *= a;
	printf("Operador *=. Valor de c = %d\n", c);

	c /= a;
	printf("Operador /=. Valor de c = %d\n", c);

	c %= a;
	printf("Operador %=. Valor de c = %d\n", c);

	c <<= 2;
	printf("Operador <<=. Valor de c = %d\n", c);

	c >>= 2;
	printf("Operador >>=. Valor de c = %d\n", c);

	c &= 2;
	printf("Operador &=. Valor de c = %d\n", c);

	c ^= 2;
	printf("Operador ^=. Valor de c = %d\n", c);

	c |= 2;
	printf("Operador |=. Valor de c = %d\n", c) 


	  }


    #+END_SRC


    Cuando compilemos y ejecutemos el programa anterior, producirá el siguiente resultado -- 

    : Operador =. Valor de c 21  
    : Operador +=. Valor de c 42 
    : Operador -=. Valor de c 21 
    : Operador *=. Valor de c 441 
    : Operador /=. Valor de c 21 
    : Operador %=. Valor de c 11 
    : Operador <<=. Valor de c 44 
    : Operador >>=. Valor de c 11 
    : Operador &=. Valor de c 2 
    : Operador ^=. Valor de c 0 
    : Operador |=. Valor de c 2 

** Operadores mixtos &map; sizeof y ternary

   Además de los Operador ya vistos hay unos pocos importantes operadores incluyendo *sizeof* y *?* : soportados por C

   | Operador | Descripción                          | Ejemplo                                    |
   |----------+--------------------------------------+--------------------------------------------|
   | sizeof() | Devuelve el valor de la variable     | sizeof(a), devolverá 4                     |
   | &        | Devuelve la dirección de la variable | &a, devolverá su dirección                 |
   | ,*       | Puntero a una variable               | *a;                                        |
   | ? :      | Expresión condicional                | Si la condición es true entonces X, sino Y |

*** Ejemplo 

    Vamos a ver el siguiente ejemplo para entender todos los operadores mixtos disponibles en C -- 

    #+BEGIN_SRC C

      #include <stdio.h>

      main(){

	int a = 4;
	short b;
	double c;
	int* ptr;

	/* ejemplo del operador sizeof */
	printf("El tamaño de la variable a es %d\n", sizeof(a));
	printf("El tamaño de la variable b es %d\n", sizeof(b));
	printf("El tamaño de la variable c es %d\n", sizeof(c));

	/* ejemplo de los operadores & y * */

	ptr = &a; /* 'ptr' ahora contiene la dirección de 'a' */
	printf("El valor de a es %d\n", a);
	printf("*ptr es %d.\n", *ptr);

	/*ejemplo de operadores ternarios */
	a = 10;
	b = (a == 1) ? 20: 30;
	printf("El valor de b es %d\n, b");

	b = (a == 10) ? 20: 30;
	printf("El valor de b es %d\n", b);
      }

    #+END_SRC

    Cuando compilemos y ejecutemos el programa anterior, obtendremos el siguiente resultado -- 

    : El tamaño de la variable a es 4
    : El tamaño de la variable b es 2
    : El tamaño de la variable c es 8
    : El valor de a es 4
    : *ptr es 4.
    : El valor de b es 30
    : El valor de b es 20


** Precedencia de operadores 

   La precedencia de operadores determina el agrupamiento de terminos en una expresión y decide cómo una expresión es evaluada. Ciertos operadores tienen mayor precedencia que otros; por ejemplo, el operador de multiplicación tiene mayor precedencia que el operador de suma. 

   Por ejemplo, x = 7 + 3 * 2; aquí, x es asignado a 13, no 20 porque el operador * tiene mayor precedencia que +, así primero se multiplica 3*2 y después se añade 7.

   Aquí, operadores con mayor precedencia aparecen arriba de la tabla, y los que tienen menos aparecen al fondo. En una expresión, los de más alta precedencia será evaluados primero. 

   | Categoria       | Operador                         | Asociatividad       |
   |-----------------+----------------------------------+---------------------|
   | Sufijos         | ()[]->.++--                      | Izquierda a Derecha |
   | Unarios         | + - ! ~ ++ -- (type)* & sizeof   | Derecha a Izquierda |
   | Multiplicativos | * / %                            | Izquierda a Derecha |
   | Aditivos        | + -                              | Izquierda a Derecha |
   | Desplazamiento  | << >>                            | Izquierda a Derecha |
   | Relacionales    | < <= > >=                        | Izquierda a Derecha |
   | Equidad         | \== !=                           | Izquierda a Derecha |
   | AND Bit         | &                                | Izquierda a Derecha |
   | XOR Bit         | ^                                | Izquierda a Derecha |
   | OR Bit          | ¦                                | Izquierda a Derecha |
   | AND Logico      | &&                               | Izquierda a Derecha |
   | OR Logico       | ¦¦                               | Izquierda a Derecha |
   | Condicional     | ?:                               | Derecha a Izquierda |
   | Asignación      | \= += -= *= /= %=>>= <<= &= ^=¦= | Derecha a Izquierda |
   | Coma            | ,                                | Izquierda a Derecha |

*** Ejemplo

    Veremos el siguiente ejemplo para entender la precedencia en los operadores en C -- 

    #+BEGIN_SRC C

      #include <stdio.h>

      main(){

	int a = 20;
	int b = 10;
	int c = 15;
	int d = 5;
	int e;

	e = (a + b) * c / d; // (30 * 15 ) / 5
	printf("El valor de (a + b) * c / d es : %d\n", e);

	e = ((a + b) * c) / d;  // (30 * 15) / 5
	printf("El valor de ((a +  b) * c) / d es : %d\n", e);

	e = (a + b) * (c / d); // (30) * (15/5)
	printf("El valor de (a + b) * (c / d) es : %d\n", e);

	e = a + (b * c) / d; // 20 + (150/5)
	printf("El valor de a + (b * c) / d es : %d\n", e);

	return 0;

      }

    #+END_SRC


    Cuando compilemos y ejecutemos el programa anterior producirá el siguiente resultado -- 


    : El valor de  (a + b) * c / d  es : 90
    : El valor de  ((a + b) * c) /  es : 90
    : El valor de  (a + b) * (c / d es : 90
    : El valor de  a + (b * c) / d  es : 50

* C - Tomando decisiones 

  Las estructuras  para tomar decisiones requieren que el programador especifique una o más condiciones para ser evaluadas o testadas por el programa, a lo largo con una declaracón o declaraciones para ser ejecutadas si la condición es determinadas a ser cierta, y opcionalmente, otra declaración para ser ejecutada si la condición es determinada a ser falsa. 

  Mostramos abajo un forma general de la estructura de toma de decisiones encontrada en la mayoría de los lenguajes de programación - 

  # image

  El lenguaje de programación C proporciona los siguientes tipos de declaraciones para toma de decisiones. 

  | Nº | Declaración           | Descripción                                                                        |
  |----+-----------------------+------------------------------------------------------------------------------------|
  |  1 | declaración if        | consiste en una expresión buleana seguida de una o más declaraciones               |
  |  2 | declaración if...else | Es un if con un else opcional que ejecuta una declaración si la expresión es falsa |
  |  3 | if anidados           | Se pueden usar if o else if anidados                                               |
  |  4 | declaración switch    | Se compara contra una lista de valores                                             |
  |  5 | switch anidados       | se puede usar un switch dentro de otro                                             |


** El operador ?:

   Ya hemos cubierto el *operador condicional ?:* en el capítulo anterior el cual puede ser usado para reemplazar la declaración *if...else*. Su forma general es -- 

   : Exp1 ? Exp2 : Exp3;

   Donde Exp1, Exp2 y Exp3 son expresiones. 

   El valor de la expresión ? es determinadas como esto - 

   * Exp1 es evaluada. Si es verdadera, entonces Exp2 es evaluada y se convierte el valor de la expresión ?

   * Si Exp1 es falso, entonces Exp3 es evaludado y su valor se convierte en el valor de la expresión

* C - Bucles 


  Nos podemos encontrar situaciones, donde un bloque de código necesita ser ejecutado un cierto número de veces. En general, las declaraciones son ejecutadas secuencialmente: la primera declaración en una función es ejecutada primero, seguido de la segunda y así. 

  Los lenguajes de programación proporcionan varias estructuras de control que permiten caminos de ejecución más complicados. 

  Una declaración bucle nos permite ejecutar una declaración o grupo de ellas muchas veces. Dado la siguiente forma general de una declaración bucle en la mayoría de lenguajes de programación  -- 

  # imagen 

  El lenguaje de programación C proporciona los siguientes tipos de bucles - 

  | Nº | Tipo de Bucle    | Descripción                                                                                |
  |----+------------------+--------------------------------------------------------------------------------------------|
  |  1 | bucle while      | repite una declaración mientras una condición dada sea cierta.                             |
  |  2 | bucle for        | Ejecuta una secuncia de declaraciones muchas veces y abrevia el código que maneja el bucle |
  |  3 | bucle do...while | Es más como un bucle while, solo que se testea la condición al final del bucle             |
  |  4 | bucles anidados  | Se puede usar un bucle dentro de otro                                                      |

*** Bucle while en C 

Un bucle *while* en C repetidamente ejecuta una declaración objetivo mientras la condición sea verdadera. 

**** Sintaxis 

     La sintaxis de un bucle *while* en C es - 

     #+BEGIN_SRC C

       while(condicion) {
	 declaracion(es);
	}

     #+END_SRC


     Aquí, *declaracion(es) puede ser una sola declaración o un bloque de declaraciones. La *condición* puede ser cualquier expresión, y verdadero es cualquier valor no cero. El bucle itera mientras la condición sea cierta.

     Cuando la condición se convierte en falsa, el programa pasa el control a la linea inmediatamente después del bucle.

**** Diagrama de Flujo 


# imagen


Aquí, el punto clave a notar es que un bucle while puede que no se ejecute. Cuando la condición es comprobada y su resultado es falso, el cuerpo del bucle será omitido y la primera declaración después de que el bucle while sea ejecutado. 

**** Ejemplo  

     #+BEGIN_SRC C

       #include <stdio.h>

       int main() {

	 /* definimos las variables locales */
	 int a = 10;

	 /* ejecución del bucle while */ 
	 while( a < 20 ) {
	   printf("el valor de a es: %d\n", a);
	   a++;
	 }

	 return 0;
       }
     #+END_SRC

     Cuando compilamos el código y lo ejecutamos producirá el siguiente resultado - 

     : el valor de a es : 10
     : el valor de a es : 11
     : el valor de a es : 12
     : el valor de a es : 13
     : el valor de a es : 14
     : el valor de a es : 15
     : el valor de a es : 16
     : el valor de a es : 17
     : el valor de a es : 18
     : el valor de a es : 19

*** Bucle For en C 

    Un bucle *for* es una estructura de control de repetición que permiete eficazmente escribir bucles que se necesiten ejecutar un número específico de veces. 

**** Sintaxis 

     La sintaxis de un bucle *for* en C es - 

     #+BEGIN_SRC C

       for (inicio; condición; incremento) {
	 declaracion(es);
	}

     #+END_SRC

     Vamos a ver el flujo de control de un bucle 'for' - 

     + El paso *inicial* es ejecutado primero, y solo una vez. Este paso nos permite declarar e inicializar cualquier variable de control del bucle. No es obligatorio poner una declaración aquí, así como un punto y como aparece.

     + Siguiente, la *condición* es evaluada. Si es verdadero, el cuerpo del bucle es ejecutado. Si es falso, no se ejecuta y el flujo de control salta a la siguiente declaración justo después del bucle 'for'. 

     + Después de que el cuerpo del bucle es ejecutado, el flujo de control salta atrás a la declaración *incremento*. Esta declaración nos permite actualizar las variables de control del bucle. Esta declaración se puede dejar en blanco, poniendo un punto y como después de la condición.

     + La condición ahora es evaluada de nuevo. Si es verdadero, el bucle se ejecuta y el proceso se repite de nuevo. Después de que la condición se convierta en falso, el bucle 'for' termina.

**** Diagrama de Flujo 

     # imagen

**** Ejemplo 


     #+BEGIN_SRC C

       #include <stdio.h>

       int main () {

	 int a;

	 /* ejecución del bucle for */
	 for (a = 10; a < 20; a = a + 1){
	   printf("el valor de a es: %d\n", a);
	 }

	 return 0;
       }

     #+END_SRC


*** Bucle do...while 

    A diferencia de los bucles *for* y *while*, los cuales comprueban la condición del bucle al principio del bucle, el bucle *do...while* comprueba la condicion al final. 

    Un bucle *do...while* es similar a un bucle *while*, excepto por el hecho de que está garantizado que se ejecute al menos una vez.

**** Sintaxis 

     La sintaxis del bucle *do...while* es la siguiente - 

     #+BEGIN_SRC C

       do {
	 declaracion(es);
	} while (condición);

     #+END_SRC

     Vamos a fijarnos que la expresión de la condición aparece al final del bucle, así la declaración(es) en el bucle se ejecuta al menos una vez antes de que la condición sea comprobada. 

     Si la condición es verdadera, el flujo de control salta para atrás al principio del bucle, y así la declaración se ejecuta de nuevo. Este proceso se repite hasta que la condición dada sea falsa. 

**** Diagrama de Flujo 

# imagen 

**** Ejemplo 

     #+BEGIN_SRC C

       #include <stdio.h>

       int main() {
	 /* definición de variables locales */
	 int a = 10;

	 /* ejecutar el bucle */
	 do {
	   printf("el valor de a es: %d\n", a);
	   a = a + 1;
	 }while( a < 20 );

	 return 0;

       }
     #+END_SRC

     Cuando compilemos y ejecutemos el código anterior tendremos el siguiente resultado - 

     : el valor de a es: 10
     : el valor de a es: 11
     : el valor de a es: 12
     : el valor de a es: 13
     : el valor de a es: 14
     : el valor de a es: 15
     : el valor de a es: 16
     : el valor de a es: 17
     : el valor de a es: 18
     : el valor de a es: 19



*** Bucles anidados 

    C permite el uso de bucles anidados. La siguiente sección muestra unos pocos ejemplos para ilustrar este concepto. 

**** Sintaxis 

     La sintaxis para un  *bucles anidados for* es la siguiente - 

     #+BEGIN_SRC C
       for ( inicialización; condición; incremento) {
	 for (inicialización; condición; incremento) {
	   declaraciones;
	 }
	 declaraciones;
	}

     #+END_SRC

     La sintaxis para un *bucle anidado while* es  la siguiente -

     #+BEGIN_SRC C
       while(condición){
	 while(condición){
	   declaraciones;
	 }
	 declaraciones;
	}
     #+END_SRC

     La sintaxis para un *bucle anidado do...while* es la siguiente - 

     #+BEGIN_SRC C

       do {
	 declaraciones;
	 do {
	   declaraciones;
	 }while (condición);
	} while (condición);

     #+END_SRC

     Una nota final acerca de los bucles anidados es que podemos poner cualquier tipo de bucle dentro de otro.Por ejemplo un bucle 'for' dentro de un bucle 'while' o viceversa. 

**** Ejemplo 

     El siguiente programa usa un bucle anidado for para encontrar los números primos desde 2 a 100 - 

     #+BEGIN_SRC C

       #include <stdio.h>

       int main () {
	 /* definiendo las variables locales */
	 int  i, j;

	 for(i = 2; i<100; i++){
	   for(j = 2; j <= (i/j); j++)
	     if(!(i%j)) break; // si se encuentra el factor no es primo
	   if(j > (i/j)) printf("%d es primo/n", i);
	 }

	 return 0;
       }

     #+END_SRC

     Cuando compilemos y ejecutemos el siguiente código producirá el siguiente resultado - 

     : 2 es primo 
     : 3 es primo 
     : 5 es primo 
     : 7 es primo 
     : 11 es primo 
     : 13 es primo 
     : 17 es primo 
     : 19 es primo 
     : 23 es primo 
     : 29 es primo 
     : 31 es primo 
     : 37 es primo 
     : 41 es primo 
     : 43 es primo 
     : 47 es primo 
     : 53 es primo 
     : 59 es primo 
     : 61 es primo 
     : 67 es primo 
     : 71 es primo 
     : 73 es primo 
     : 79 es primo 
     : 83 es primo 
     : 89 es primo 
     : 97 es primo 


** Declaraciones para el control de bucles 

Las declaraciones de control de bucles cambian la ejecución de su secuencia normal. Cuando la ejecución deja un ámbito, todos los objetos automáticamente que son creados en ese ámbito son destruidos. 

C soporta las siguientes declaraciones de control 

| Nº | Declaración de Control | Descripción                                                |
|----+------------------------+------------------------------------------------------------|
|  1 | declaración break      | Termina el bucle o switch y lo transfiere al siguiente     |
|  2 | declaración continue   | Causa que el bucle salga de su cuerpo y vuelva a testearse |
|  3 | declaración goto       | Transfiere el control a una declaración nombrada           |


** Declaración break
   La declaración *break* en C tiene dos usos - 

   * Cuando una declaración *break* es encontrada dentro de un bucle, el bucle termina de forma inmediata y el control del programa pasa a la siguiente declaración que sigue al bucle.
   * Puede ser usado para terminar un caso en la declaración *switch* (que veremos en el próximo capítulo).

   Si estamos usando bucles anidados, la declaración break parará la ejecución de bucle más interno y pasará a la siguiente línea del siguiente bloque. 

*** Sintaxis 
    La sintaxis para *break* es la siguiente - 

    #+BEGIN_SRC C
      break;
    #+END_SRC

*** Diagrama de Flujo 

# imagen 
*** Ejemplo  


    #+BEGIN_SRC C
      #include <stdio.h>

      int main(){
	/* definiendo las variables locales */
	int a = 10;

	/* ejecución del bucle while */
	while(a < 20 ) {
	  printf("El valor de a: %d\n", a);
	  a++;

	  if( a > 15) {
	    /* terminando el bucle con break */
	    break;
	  }
	}

	return 0;
      }

    #+END_SRC

    Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado - 

    : El valor de a: 10
    : El valor de a: 11
    : El valor de a: 12
    : El valor de a: 13
    : El valor de a: 14
    : El valor de a: 15


** Declaración continue 

La declaración *continue* en C funciona algo como la declaración *break*. En vez de forzar el fin, fuerza que la próxima iteración del bucle tome lugar, saltando el código entre ello.

Para el bucle *for*, *continue* causa que la comparación condicional y el incremento sean ejecutados. Para el bucled *do...while*, *continue* causa que el control del programa pase al chequeo condicional.

*** Sintaxis  
 

    La sintaxis para *continue* es la siguiente - 

    #+BEGIN_SRC C
      continue;
    #+END_SRC

*** Diagrama de flujo 

# imagen 

*** Ejemplo 

    #+BEGIN_SRC C

      #include <stdio.h>

      int main () {
	/* definimos la variables locales */
	int a = 10;

	/* ejecutamos el bucle */
	do {

	  if( a == 15 ) {
	    /*salimos de la iteracion*/
	    a = a + 1;
	    continue;
	  }

	  printf("El valor de a es: %d\n", a);
	  a++;
	} while ( a < 20);

	return 0;

      }

    #+END_SRC


    Cuando el código anterior sea compilado y ejecutado tendremos el siguiente resultado - 

    : El valor de a es: 10
    : El valor de a es: 11
    : El valor de a es: 12
    : El valor de a es: 13
    : El valor de a es: 14
    : El valor de a es: 15
    : El valor de a es: 16
    : El valor de a es: 17
    : El valor de a es: 18
    : El valor de a es: 19

 


** Declaración goto


   La declaración *goto* en C proporciona un salto incondicional desde 'goto' hasta la declaracion nombrada en la misma función. 

   *NOTA* - Usar la declaración *goto** es altamente desaconsejado en cualquier lenguaje de programación porque hace difícil tracer el flujo de control de un programa, haciendo el programa difícil de entender y de modificar. Cualquier programa que use un goto puede ser reescrito sin ellos. 

*** Sintaxis    

    La sintaxis de la declaración *goto* en C es tal como sigue - 

    #+BEGIN_SRC C
      goto label;
      ..
      .
      label: declaración;
    #+END_SRC

    Aquí *etiqueta* puede ser cualquier texto plano excepto las palabras claves de C y puede estar en cualquier sitio en el programa antes o después de la declaración *goto*. 

*** Diagrama de Flujo 

# imagen 

*** Ejemplo 

    #+BEGIN_SRC C

      #include <stdio.h>

      int main () {
	/* definición de las variables locales */
	int a = 10;

	/* ejecución del bucle */
       LOOP:do {

	  if(a == 15){
	    /*salida de la interacción */
	    a = a + 1;
	    goto LOOP;
	  }

	  printf("El valor de a es: %d\n", a);
	  a++;
	}while(a < 20 );

	return 0;
      }
    #+END_SRC

    Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado - 


    : El valor de a es: 10
    : El valor de a es: 11
    : El valor de a es: 12
    : El valor de a es: 13
    : El valor de a es: 14
    : El valor de a es: 15
    : El valor de a es: 16
    : El valor de a es: 17
    : El valor de a es: 18
    : El valor de a es: 19

 
** Bucle infinito 

   Un bucle se vuelve un bucle infinito si una condición nuna se convierte en falsa. El bucle *for* es tradicionalmente usado para este propósito. Desde que ninguna de las tres expresiones que forma el bucle 'for' son requeridos, podemos hacer un bucle sin fin dejando la expresión condicional vacía. 


   #+BEGIN_SRC C

     #include <stdio.h>

     int main(){

       for( ; ; ){
	 printf("Este bucle no tiene fin.\n");
       }

       return 0;

     }


   #+END_SRC


   Cuando una expresión condicional está ausente, se asume que es cierta. Se podría tener una expresión de inicialización e incremento, pero los programadores de C más comúnmente usan el constructor for significar un bucle infinito.


* C - Funciones 


  Una función es un grupo de declaraciones que juntas realizan una tarea. Cada programa de C tiene al menos una función, la cual es *main()*, y todos la mayoría de programas triviales pueden definir funciones adicionales. 

  Podemos dividir nuestro código en funciones separadas. Cómo dividir nuestro código en diferentes funciones es cosa nuestra, pero lógicamente la división es de tal forma que cada función realice una tarea específica.

  Una función *declaración* le dice al compilador sobre el nombre de la función, devuelve el tipo, y los parámetros. Una función *definición* proporcional el verdadero cuerpo de la función.

  La biblioteca estándar de C proporciona numerosas funciones construidas que nuestro programa puede llamar. Por ejemplo, *strcat()* concatena dos cadenas de caracteres, *memcpy()* copia una locación de memoria a otra, y muchas más funciones. 

  Una función puede también referirse como un método o una sub-rutina o un procedimiento, etc. 

** Definiendo una función

   La forma general de la definición de una función en C es como sigue -- 

   #+BEGIN_SRC C

     tipo_a_devolver nombre_funcion (lista de parámetros) {
       cuerpo de la función
	 }

   #+END_SRC

   La definición de una función consiste en la cabecera de la función y su cuerpo. Aquí están todas las partes de una función - 

   * *Tipo de retorno* - Una función puede devolver un valor. Un *tipo_retorno* es el tipo de dato de el valor que la función devuelve. Algunas funciones realizan la operación deseada sin devolver un valor. En este caso, el tipo_retorno es la palabra clave *void*. 

   * *Nombre de la función* - Este es el verdadero nombre de la función. El nombre de la función y la lista de los parámetros juntos constituyen la firma de la función.

   * *Parámetros* - Un parámetro es como un marcador. Cuando una función es invocada, le pasamos un valor al parámetro. Este valor es referido como el verdadero parámetro o argumento. La lista de parámetros se refiere al tipo, orden y número de parámetros de una función. Los parámetros son opcionales; esto es, una función puede no contener parámetros.

*** Ejemplo 

    Dado el siguiente código fuente para una función llamada *max()*. Esta función toma dos parámetros num1 y num2 y devuelve el valor máximo entre los dos - 

    #+BEGIN_SRC C

      /* la función devuelve el máxido de dos números */
      int max((int num1, int num2){

	  /* declaración de variables locales */
	  int resultado;

	  if(num1 > num2)
	    result = num1;
	  else
	    resultado = num2;

	  return result;
	}
    #+END_SRC


** Declaración de función

   Una declaración de función le dice al compilador sobre el nombre de la función y como llamar a la función. El verdadero cuerpo de la funcion puede ser definido separadamente. 

   Una declaración de función tiene las siguientes partes - 

   : int max(int num1, int num2);

   Los nombres de los parámetros no son importantes en la declaración de la función solo su tipo es requerido, así lo siguiente también es válido - 

   :int max(int, int);

   La declaración de la función es  requerida cuando definimos una función en un archivo fuente y llamamos a la función desde otro archivo. En tal caso, podríamos declarar la función arriba del archivo llamando a la función.

** Llamando a una función

   Mientras creamos un función en C, le damos una definición de lo que la función tiene que hacer. Para usar una función, llamaremos a esa función para realizar una tarea definida. 

   Cuando un programa llama a una función, el control de programa es transferido a la función llamada. Una función llamada realiza una tarea definida y cuando es devuelta la declaración es ejecutada o cuando la función alcanza el final, se devuelve el control al programa principal.

   Para llamar a una función,, simplemente necesitamos pasar el los parámetros requeridos con el nombre de la función, y si la función devuelve un valor, entonces podemos guardar el valor devuelto. Por ejemplo - 

   #+BEGIN_SRC C

     #include <stdio.h>

     /* declaración de la función */
     int max(int num1, int num2);

     int main(){

       /*definiendo las variables locales*/
       int a = 100;
       int b = 200;
       int ret;

       /*llamando a la función que obtiene el valor máximo*/
       ret = max(a,b);

       printf("El valor máximo es: %d\n", ret);

       return 0;
     }

     /* función que devuelve el máximo número de dos */
     int max(int num1, int num2) {

       /* declaración de variables locales */
       int result;

       if (num1 > num2)
	 result = num1;
       else
	 result = num2;

       return result;
     }


   #+END_SRC


   Una vez compilado y ejecutado el código fuente obtendremos el siguiente resultado - 

   : El valor máximo es: 200

** Argumentos de la función

   Si una función va a usar argumentos, se deberán declarar las variables que aceptaran los valores de los argumentos. Esas variables son llamadas los *parámetros formales* de la función.

   Los parámetros formales se comportan como otras variables locales dentro de la función y son creadas cuando se entra en la función y se destruyen al salir.

   Mientras llamamos a una función, hay dos formas en las cuales los argumentos pueden ser pasados a la función - 

   | Nº | Tipo llamada           | Descripción                                                                                                                                                                                                                                                |
   |----+------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
   |  1 | Llamada por valor      | Este método copia el valor verdadero de un argumento en el parámetro formal de la función. En este caso, los cambios hechos a el parámetro dentro de la función no tiene efecto en el argumento                                                            |
   |  2 | Llamada por referencia | Este método copia la dirección de un argumento dentro del parámetro formal. Dentro de la función, la dirección es usada para acceder al verdadero argumento usado en al llamada. Esto significa que los cambios hechos a el parámetro afectan al argumento |
   |                                                                                                                                                                                                                                                            |

   Por defecto, C usa *llamada por valor* para pasar los argumentos. En general, significa que el código en la función no puede alterar el argumento usado para llamar a la función.

** Llamada por valor 

   El método *llamada por valor*  de pasar argumentos a una función copia el valor actual de un argumento en el parámetro formal de la función. En este caso, los cambios hechos al parámetro dentro de la función no tienen efecto en el argumento.

   Por defecto, los programas en C usar por defecto /la llamada por valor/. En general, esto significa que el código en la función no puede alterar los argumentos usados para llamar a la función. Vamos a considerar la función *intercambio()* como sigue 

   #+BEGIN_SRC C

     /* definición de la función para intercambiar los valores */
     void intercambio(int x, int y) {

       int temp;

       temp = x; /* salvamos el valor de x */ 
       x = y;  /* ponemos y en x */
       y = temp; /* ponemos temp en y */

       return;

     }

   #+END_SRC

   Ahora, vamos a llamar a la función *intercambio()* para pasarle los valores reales como sigue - 

   #+BEGIN_SRC C

     #include <stdio.h>

     /* declaración de la función */ 
     void intercambio(int x, int y);

     int main() {

       /* definición de las variables locales */
       int a = 100;
       int b = 200;

       printf("Antes del intercambio, el valor de a es: %d\n", a);
       printf("Antes del intercambio, el valor de b es: %d\n", b);

       /* llamada al intercambio de valores */
       swap(a, b);

       printf("Después del intercambio, el valor de a es: %d\n", a);
       printf("Después del intercambio, el valor de b es: %d\n", b);

       return 0;

     }

   #+END_SRC


   Una vez compilado y ejecutado el código anterior tendremos el resultado - 


   : Antes del intercambio, el valor de a es: 100
   : Antes del intercambio, el valor de b es: 200
   : Después del intercambio, el valor de a es: 100 
   : Después del intercambio, el valor de b es: 200


   Esto muestra que no hay cambio en los valores, una vez que ellos han sido cambiados dentro de la función. 


** Llamada por referencia 


   El método *llamada por referencia* de pasar argumentos a una función copia la dirección de un argumento dentro del parámetro formal. Dentro de la función, la dirección es usada para acceder al verdadero argumento usado en la llamada. Esto significa que los cambios hechos al parámetro afecta al argumento pasado. 

   Para pasar por referencia, los punteros a argumentos son pasados a la función solo como otro valor. Así en consecuencia, necesitamos declarar los parámetros de la función como tipo punteros en la siguiente función *intercambio()*, la cual cambiará el valor de las dos variables enteras, por sus argumentos. 

   #+BEGIN_SRC C

     /* definición de función para cambiar los valores */ 
     void intercambio(int *x, int *y) {

       int temp;
       temp = *x;  /* salvamos el valor de la dirección x */
       ,*x = *y;    /* ponemos y en x */
       ,*y = temp;  /* ponemos temp en y */

       return;

     }

   #+END_SRC

   Ahora vamos a llamar a la función *intercambio()* pasándole los valores por referencias --

   #+BEGIN_SRC C


     #include <stdio.h>

     /* declaración de la función */
     void intercambio(int *x, int *y);

     int main(){

       /* definición de las variables locales */
       int a = 100;
       int b = 200;

       printf("Antes del intercambio, el valor de a es: %d\n", a);
       printf("Antes del intercambio, el valor de a es: %d\n", b);

       /* llamando a la función a cambiar los valores.
	  • &a indica puntero a a, e.i. la dirección de la variable a y
	  • &b indica puntero a b, e.i. la dirección de la variable b.
       ,*/
       intercambio(&a, &b);

       printf("Después del intercambio, el valor de a es: %d\n", a);
       printf("Después del intercambio, el valor de b es: %d\n", a);

       return 0;

     }


   #+END_SRC


   Una vez compilado y ejecutado el código anterior, tendremos el siguiente resultado - 

   : Antes del intercambio, el valor de a es: 100
   : Antes del intercambio, el valor de b es: 200
   : Después del intercambio, el valor de a es: 200
   : Después del intercambio, el valor de b es: 100

   Esto muestra que los cambios se reflejan fuera de la función también, a diferencia de la llamada por valor donde los cambios no se reflejan fuera de la función. 

* C - Reglas de ámbito

  Un ámbito en programación es una región del programa donde una variable definida puede tener su existencia y más allá de eso la variable no puede ser accedida. Hay tres lugares donde las variables pueden ser declaradas en C -

  * Dentro de una función o un bloque las cuales son llamadas variables *locales*.
  * Fuera de todas las funciones las cuales son llamadas variables *globales*.
  * En la definición de una función las cuales son llamados parámetros *formales*.

  Entenderemos lo que son variables *locales* y *globales* y parámetros *formales*. 

** Variables locales 

Las variables que son declaradas dentro de una función o bloque son llamadas variables locales. Ellas pueden ser usadas solo por declaraciones que están dentro de esa función o bloque de código. Las variables locales no son conocidas por funciones de fuera. El siguiente ejemplo mostrará como las variables locales son usadas. 

#+BEGIN_SRC C

  #include <stdio.h>

  int main(){

    /* declaración de variables locales */
    int a, b;
    int c;

    /* inicialización real */
    a = 10;
    b = 20;
    c = a + b;

    printf("El valor de a = %d, b = %d y c = %d\n", a, b, c);

    return 0;

  }

#+END_SRC

** Variables globales 

Las variables globales son definidas fueras de las funciones, normalmente al principio del programa. Las variables globales mantienen sus valores a través del tiempo de vida del programa y pueden ser accedidas dentro de cualquier función definida por el programa. 

Una variable global puede ser accedida por cualquier función. Esto es, una variable global está disponible para el uso a través de todo el programa después de su declaración. El siguiente programa muestra como las variables globales son usadas. 

#+BEGIN_SRC C

  #include <stdio.h>

  /*declaración de variables globales */
  int g;

  int main(){
    /*declaración de variables locales */
    int a, b;

    /*verdadera inicialización */
    a = 10;
    b = 20;
    g = a + b;

    printf("El valor de a = %d, b = %d y g = %d\n", a, b, g);

    return 0;
  }

#+END_SRC


En un programa puede haber variables locales y globales con el mismo nombre pero el valor de las variables locales dentro de una función tomarán preferencia. Aquí un ejemplo - 


#+BEGIN_SRC C

  #include <stdio.h>

  /*declaración de variable global */
  int g = 20;

  int main(){
    /* declaración de variable local */
    int g = 10;

    printf("El valor de g = %d\n", g);

    return 0

      }

#+END_SRC

Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado -

: El valor de g = 10

** Parámetros formales*

Los parámetros formales, son tratados como variables locales en una función y se toman precedidos sobre las variables globales. Veamos el siguiente ejemplo - 

#+BEGIN_SRC C

  #include <stdio.h>

  /* declaración de la variable global */
  int a = 20;

  int main() {

    /* declaración de la variable local en la función main */
    int a = 10;
    int b = 20;
    int c = 0;

    printf ("El valor de a en main() es %d\n", a);
    c = sum(a, b);
    printf ("El valor de c en main() es %d\n", c);

    return 0;

  }

  /*función para añadir dos enteros */
  int sum(int a, int b) {

    printf("El valor de a en sum() es %d\n", a);
    printf("El valor de b en sum() es %d\n", b);

    return a + b;
  }

#+END_SRC


Cuando compilemos y ejecutemos el código anterior, tendremos el siguiente resultado - 

: El valor de a en main() es  10
: El valor de a en sum() es 10
: El valor de b en sum() es 20
: El valor de c en main() es 30 

** Inicialización de variables Locales y Globales 


Cuando una variable local es definida, no es inicializada por el sistema, hay que inicializarla por uno mismo. Las variables Globales son inicializadas por el sistema automáticamente cuando las definimos de la siguiente forma 

| Tipo de Dato | Valor inicial por defecto |
|--------------+---------------------------|
| int          |                         0 |
| char         |                      '\0' |
| float        |                         0 |
| double       |                         0 |
| pointer      |                      NULL |

* C - Arrays 

Los Arrays son un tipo de estrucutra de datos que pueen guardar una colección secuencial de tamaño fijo de elementos del mismo tipo. Un array es usado para guardar una colección de atos, pero esto ofrece más utilidades de lo que se pueda imaginar de un array como una colección de variables del mismo tipo. 

En vez de declarar variables individuales, tal como numero1, numero2, ... y número99, podemos declarar un array de variables tals como números y usar números[0], números[1], y ... número[99] para  representar variables individuales. Un elemento específico en una rray es accedido a través de un índice. 

Todo array consiste en locaciones de memoria contiguas. Las direcciones más bajas corresponde al primer elemento y las más altas al último elemento 

# imagen 

** Declarando Arrays 

Para declarar un array en C, un programador especifica el tipo de elementos y su número requeridos por el array de la siguiente manera - 

: tipo nombreArray [ tamañoArray ];

Esto es llamado un array /uni-dimensional/. el *tamañoArray* debe ser un entero constante mayor de cero y el *tipo* puede ser cualquier tipo de dato C válido. Por ejemplo, para declarar un array de 10 elementos llamado *balance* de tipos dobles, usaremos esta declaración - 

: double balance[10];

Aquí balance es el array de variables el cual es suficente para guardar 10 números dobles.


** Inicializando Arrays 

Podemos inicializar un array en C yendo uno por uno o usando una única declaración como sigue - 

: double balace[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};

Crearemos exactamente el mismo array que hicimos en el capítulo anterior. Lo siguiente es un ejemplo de asignar un único elemento al array - 

: balance[4] = 50.0;

La declaración anterior asigna al quinto elemento del array el valor de 50.0. Todos los arrays empiezan con 0 como su primer elemento el cual es también llamado el índice base y el último índice del array es el tamaño total menos 1. Veremos la siguiente imagen:

# imagen 

** Accediendo a Elementos del Array

Un elemento es accesible por el índice del array. Esto es poniendo el índice del elemento dentro de corchetes después del nombre del array. Por ejemplo - 

: double salario = balance[9];

Esta declaración tomará el elemento 10 del array y lo asignará el valor a la variable salario. El siguiente ejemplo muestra como usar todos los tres conceptos mencionados, declaración, asignación y accesibilidad al array. --

#+BEGIN_SRC C

  #include <stdio.h>

  int main() {
    int n[ 10 ]; /* n es un array de 10 enteros */
    int i,j;

    /* inicializar los elementos del array n a 0 */
    for ( i = 0; i < 10; i++) {
      n[ i ] = i + 100; /* establecemos los elementos en la localización i a i + 100 */
    }

    /* salida del valor de cada elemento */
    for (j = 0; j < 10; j++ ) {
      printf("Elemento[%d] = %d\n", j, n[j] );
    }

    return 0;

  }

#+END_SRC


Una vez compilado y ejecutado el código, producirá el siguiente resultado - 

: Elemento[0] = 100
: Elemento[1] = 101
: Elemento[2] = 102 
: Elemento[3] = 103
: Elemento[4] = 104
: Elemento[5] = 105
: Elemento[6] = 106
: Elemento[7] = 107
: Elemento[8] = 108
: Elemento[9] = 109

** Arrays en detalle 

Los arrays son importantes en C y deberían necesitar algo más de atención. Los siguientes importantes concepots relacionados con los arrays serán clarificadores a los programadores de C - 

| No | Concepto                         | Descripción                                                  |
|----+----------------------------------+--------------------------------------------------------------|
|  1 | Arrays Multi-dimensionales       | Son arrays en dos dimensiones                                |
|  2 | Pasando Arrays a funciones       | Podemos pasar a una función un puntero que apunte a un array |
|  3 | Devolver un array de una función | C permite a una función devolver un array                    |
|  4 | Punteros a un array              | Se puede genera un puntero al 1 elemento de un array         |


*** Arrays Multi-dimensionales 

C permite arrays multidimensionales. La declaración general para formar arrays multidimensionales es - 

: tipo nombre[tamaño1][tamaño2]..[tamañoN];

Por ejemplo, la siguiente declaración crea un array tridimensional de enteros- 

: int tresdim[5][10][4];

**** Arrays en dos dimensiones 

La forma más simple de array multidimensional es el array dos-dimensional. Un array dos-dimensional es, en esencia, una lista de arrays unidimensionales. Para declarar un array de enteros de dos-dimensional [x][y], habrá que escribir algo como lo que sigue 

: tipo nombreArray [ x ][ y ];

Donde *tipo** puede ser cualquier tipo de dato válido en C y *nombreArray* será un identificador de C válido. Un array dos-dimensional puede ser considerado como una tabla la cual tendrá un número x de filas y un número y de columnas. Un array dos-dimensional *a*, el cual contiene tres filas y cuatro columnas puede ser como el mostrado a continuación - 

# imagen 


Así, cada elemento en el array *a* es identificado por un nombre en la forma *a[i][j]*, donde 'a' es el nombre del array, e 'i' y 'j' son los subíndices que identifican cada elemento en 'a'. 

**** Inicializando un Array Dos-Dimensional 


Los arrays multidimensionales pueden ser inicializados por valores específicos entre corchetes para cada fila. Lo siguiente es un array con tres filas y cada fila tiene 4 columnas. 

#+BEGIN_SRC C
  int a[3][4] = {
                 {0, 1, 2, 3} , /*inicializamos para la fila con el índice 0 */
                 {4, 5, 6, 7} , /*inicializamos para la fila con el índice 1 */
                 {8, 9, 10, 11} /*inicializamos para la fila con el índice 2 */
  };

#+END_SRC


Las llaves anidadas, las cuales indican la fila destinada, son opcionales.La siguiente inicialización es equivalente al ejemplo anterior 

#+BEGIN_SRC C
int a[3]{4} ={0,1,2,3,4,5,6,7,8,9,10,11};
#+END_SRC

**** Accediendo a un Array Dos-Dimensional 

Un elemento en un array dos-dimensional es accesible usando subíndices, es decir, el índice de la fila y el índice de la columna. Por ejemplo - 

: int val = a[2][3];

La declaración anterior tomará el cuarto elemento de la tercera fila del array. Lo podemos verificar en la figura anterior. Comprobemos el siguiente programa donde hemos usado un bucle anidado para manejar un array en  dos-dimensiones. 

#+BEGIN_SRC C

  #include <stdio.h>

  int main(){

    /* un array con 5 filas y 2 columnas*/
    int a[5][2] = { {0,0}, {1,2},{2,4}, {3,6}, {4,8}};
    int i, j;

    /* salida de los valores de cada elemento en el array */
    for (i = 0; i < 5; i++) {

      for( j = 0;j < 2; j++ ) {
        printf("a[%d][%d] = %d\n", i,j, a[i][j] );
      } 

    }

    return 0;
  }

#+END_SRC


Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado 

: a[0][0]: 0
: a[0][1]: 0
: a[1][0]: 1
: a[1][1]: 2
: a[2][0]: 2
: a[2][1]: 4
: a[3][0]: 3
: a[3][1]: 6
: a[4][0]: 4
: a[4][1]: 8

Como explicamos anteriormente, podemos tener un array con cualquier número de dimensiones, a pesar de que la mayoría de los arrays que creemos serán una o dos dimensiones. 


*** Pasando Arrays a funciones 

Si queremos pasar un array uni-dimensional como argumento de una función, deberíamos tener que declarar un parámetro formal en uno de los siguientes tres métodos de declaración que producen similares resultados poruqe cada uno le dice al compilador qeu un puntero entero va a ser recibido. Similarmente, podemos pasar arrays multidimensionales como parámetros formales. 

**** Forma 1 

Parámetros formales como un puntero - 

#+BEGIN_SRC C

  void miFuncion(int *param) {
    .
    .
    .

  }

#+END_SRC

**** Forma 2 

Parámetro formal como un array de tamaño fijo -

#+BEGIN_SRC C

  void miFuncion(int param[10]) {
    .
    .
    .
  }

#+END_SRC

**** Forma 3

Parámetro forma como un array sin tamaño fijo - 

#+BEGIN_SRC C

  void miFuncion(int param[]) {
    .
    .
    .
  }

#+END_SRC

**** Ejemplos 


Ahora, consideremos la siguiente función, la cual toma un array como argumento a lo largo con otro argumento como base de los argumentos pasados, que devolverá la media de los números pasados a través del array de la siguiente forma - 


#+BEGIN_SRC C

  double obtenerMedia(int arr[], int tamaño) {

    int i;
    double mda;
    double sum = 0;

    for (i = 0; i < tamaño; ++i) {
      sum += arr[i];
    }

    mda = sum /tamaño;

    return mda

      }

#+END_SRC


Ahora, llamaremos a la función anterior como sigue - 

#+BEGIN_SRC C

  #include <stdio.h>

  /*declaración de la función */
  double obtenerMedia(int arr[], int tamaño);

  int main(){

    /*  un array de enteros con 5 elementos */
    int balance[5] = {1000, 2, 3, 17, 50};
    double mda;

    /*  pasamos un  puntero al array como un argumento */
    mda = obtenerMedia( balance, 5 );

    /* salida del valor devuelto */
    printf("El valor medio es: %f", mda);

    return 0;

  }

#+END_SRC

Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado - 

: El valor medio es: 214.400000

Como podemos ver, la longitud del array no importa como tan lejos la función le concierne porque C no produce comprobaciones a las uniones para los parámetros formales <-- ver esto después 


*** Devolviendo un array desde una función en C 

El lenguaje C no permite devolver un array entero como un argumento a una función. Sin embargo, podemos devolver un puntero a un  array especificando el nombre del array sin el índice. 

Si queremos retornar un array unidimensional desde una función, tenemos que declarar una función devolviendo un puntero como en el siguiente ejemplo - 

#+BEGIN_SRC C

  int * miFuncion() {
    .
    .
    .

  }

#+END_SRC

El segundo punto a recordar es que C no es partidario de devolver la dirección de una variable local fuera de la función, así que hay que definir las variables locales como variables *estáticas*. 

Ahora, consideremos la siguiente función la cual genera 10 números aleatorios y los devuelve usando un array y llamamos a esta función de la siguiente forma - 

#+BEGIN_SRC C

  #include <stdio.h>

  /* función que genera y devuelve números aleatorios */
  int * obtenerAleatorio( ) {

    static int r[10];
    int i;

    /* establecer la semilla */
    srand( (unsigned)time( NULL ) );

    for (i = 0; i < 10; ++i) {
      r[i] = rand();
      printf( "r[%d] = %d\n", i, a[i]);
    }

    return r;

  }

  /* función principal para llamar la función que hemos definido */
  int main() {

    /* un puntero a un entero */
    int *p;
    int i;

    p = obtenerAleatorio();

    for ( i= 0; i < 10; i++) {
      printf("*(p + %d) : %d\n", i, *(p + i));
    }

    return 0;

  }

#+END_SRC 


Una vez compilado y ejecutado el código anterior, se producirá el siguiente resultado - 


: r[0] = 313959809
: r[1] = 1759055877
: r[2] = 1113101911
: r[3] = 2133832223
: r[4] = 2073354073
: r[5] = 167288147
: r[6] = 1827471542
: r[7] = 834791014
: r[8] = 1901409888
: r[9] = 1990469526
: *(p + 0) : 313959809
: *(p + 1) : 1759055877
: *(p + 2) : 1113101911
: *(p + 3) : 2133832223
: *(p + 4) : 2073354073
: *(p + 5) : 167288147
: *(p + 6) : 1827471542
: *(p + 7) : 834791014
: *(p + 8) : 1901409888
: *(p + 9) : 1990469526


*** Puntero a un array 

 
Esta parte  igual no se va a entender bien hasta que no veamos mejor las sección de 'Punteros'. 

Asumiendo lo que son los punteros en C, vamos a empezar: El nombre de un array es un puntero constante al primer elemento de un array. Por lo tanto, en la declaración - 

: double balance[50];

*balance* es un puntero a &balance[0], el cual es la dirección del primer elemento del array balance. Además, el fragmento del siguiente programa asigna *p* a la dirección del primer elemento de *balance*. 


#+BEGIN_SRC C

double *p;
duble balance[10];

p = balance;

#+END_SRC

Es legal usar el nombre de un array como puntero constante, y viceversa. Por lo tanto, *(balance &plus; 4) es una forma legítima de acceder a los datos de balance[4].

Una vez guardamos la dirección del primer elemento en 'p', podemos acceder a los elementos del array usando *p, *(p&plus;1), *(p&plus;2) y así. Vamos a verlo en un ejemplo. 

#+BEGIN_SRC C

  #include <stdio.h>

  int main () {

    /* un array con 5 elementos */
    double balance[5] = { 1000.0, 2.0, 3.4, 17.0, 50.0};
    double *p;
    int i;

    p = balance

      /* salida del valor de cada elemento del array */
      printf("Valores del array usando punteros\n";

             for (i = 0; i < 5; i++) {
               printf("*(p + %d) : %f\n", i, *(p + i) );

             }

             printf("Valores del array usando balance como dirección\n");

             for ( i = 0; i < 5; i++) {
               printf("*(balance + %d) : %f\n", i, *(balance + i) );
             }

             return 0;

             }

#+END_SRC


cuando compilemos y ejecutemos el código anterior, obtendremos  el siguiente resultado - 


: Valores del array usando punteros
: *(p + 0) : 1000.000000
: *(p + 1) : 2.000000
: *(p + 2) : 3.400000
: *(p + 3) : 17.000000
: *(p + 4) : 50.000000
: Valores del array usando balance como dirección
: *(balance + 0) : 1000.000000
: *(balance + 1) : 2.000000
: *(balance + 2) : 3.400000
: *(balance + 3) : 17.000000
: *(balance + 4) : 50.000000

En el ejemplo anterior, p es un puntero a doble, lo cual significa que puede guardar la dirección de variables de tipo doble. Una vez que tenemos la dirección en p, *p nos dará el valor disponible en la dirección guardada en p, tal como hemos mostrado en el ejemplo. 

* C - Punteros
  
Los punteros en C son fácil y divertidos de aprender. Algunas tareas en C son desarrolladas de forma más fácil con punteros, y otras tareas, tales como asignación de memoria dinámica, no pueden ser hechas sin el uso de punteros. Esto convierte nececesariamente el aprendizaje de punteros en la mejor forma de convertirte en un programador de C perfecto. Empecemos a aprenderlo en simples y sencillos pasos. 

Como sabemos, cada variable tiene designada una posición de memoria y cada posición de memoria tiene su dirección definida a la cual puede ser accedida usando el operador (&), el cual denota una dirección de memoria. Consideremos el siguiente ejemplo, el cual imprime la dirección de una variable definida - 

#+BEGIN_SRC C

  #include <stdio.h>

  int main(){

    int var1;
    char var2[10];

    printf("La dirección de la variable var1 es: %x\n", &var1 );
    printf("La dirección de la variable var2 es: %x\n", &var2 );

    return 0;

  }


#+END_SRC


Cuando el código anterior es compilado y ejecutado, producirá el siguiente resultado - 

: La dirección de la variable var1 es: bff5a400
: La dirección de la variable var2 es: bff5a3f6

** Qué son los punteros

Un *puntero* es una variable cuyo valor es la dirección de otra variable, es decir, directamente la dirección de la posición de memoria. Como cualquier variable o constante, se debe declarar un puntero antes de usarlo para guardar la cualquier dirección de variable. La forma general para declarar una variable puntero es - 

: tipo *nombre-variable 

Aquí *tipo*  es el tipo base del puntero; debe ser un  tipo de dato válido y el *nombre-variable e el nombre de la variable puntero. El asterisco * usado para declarar un puntero el el mismo asterisco usado para la multiplicación. Sin embargo, en esta declaración el asterisco es usado para designar una variable como un puntero. Echemos un vistazo a algunas declaraciones validas de punteros - 

#+BEGIN_SRC C

int *ip    /*puntero a un entero*/
double *dp /*puntero a un doble*/
float *fp  /*puntero a un coma flotante*/
char *ch   /*puntero a un carácter*/

#+END_SRC 


El verdadero tipo de dato del valor de todos los punteros, ya sea entero, coma flotante, o cualquier otro , es el mismo, un número largo hexadecimal que representa una dirección de memoria. La única diferencia entre los  tipos de datos de los punteros es el tipo de dato o constante al que el puntero apunta. 

** Cómo se usa un puntero

Hay algunas pocas operaciones importantes, las cuales haremos con la ayuda de punteros muy frecuentemente. *(a)* Definiremos una variable puntero, *(b)* asignaremos la dirección de una variable a un puntero y *(c)* finalmente accederemos al valor de la dirección disponible en la variable puntero. Esto se hace usando el operador unario * que devuelve el valor de la variable localizada en la dirección especificada por su operando. El siguiente ejemplo hace uso de estas operaciones - 

#+BEGIN_SRC C

  #include <stdio.h>

  int main(){

    int var = 20; /* declaración de la variable verdadera */
    int *ip;      /* declaración de la variable puntero */

    ip = &var;  /* guardamos la dirección de var en la variable puntero */

    printf("Dirección de la variable var: %x\n", &var);

    /* dirección guardada  en la variable puntero */
    printf("Dirección guardada en la variable ip: %x\n", ip);

    /* acceso al valor usando el puntero */
    printf("Valor de la variable *ip: %d\n", *ip);

    return 0;

  }

#+END_SRC

Cuando el código anterior es compilado y ejecutado, producirá el siguiente resultado - 

: Dirección de la variable var: bffd8b3c
: Dirección guardada en la variable ip: bffd8b3c
: Valor de la variable *ip: 20

** Punteros Null

Siempre es una buena práctica asignar un valor NULL a un variable puntero en caso de que no tengamos una dirección exacta para ser asignada. Esto se hace al mismo tiempo que la declaración de la variable. Un puntero que es asignado a NULL es llamado un puntero *null*. 

El puntero NULL es una constante con un valor de cero definidos en varias bibliotecas estándares. Consideremos el siguiente programa - 

#+BEGIN_SRC C

  #include <stdio.h>

  int main() {

    int *ptr = NULL;

    printf("El valor de ptr es: %x\n", ptr);

    return 0;

  }


#+END_SRC

Cuando el código anterior es compilado y ejecutado, producirá
 el siguiente resultado - 

: El valor de ptr es 0

En muchos de los sistemas operativos, los programas no les está permitido acceder a las  direcciones de memoria en 0 porque esa memoria está reservada por el sistema operativo. Sin embargo, la dirección de memoria 0 tiene un especial significado; significa que el puntero no está intentando apuntar a ningún punto accesible de memoria. Pero por convención, si un puntero contiene el valor null (cero), se asume que no apunta a nada. 

Para comprobarlo, podemos usar la declaración 'if' como sigue - 

#+BEGIN_SRC C

if(ptr)  /* afirmativo si p no es null */
if(!ptr) /* afirmativo si p es null */


#+END_SRC

** Punteros en detalle 

Los punteros tienen muchos no fáciles conceptos y son muy importantes en C. Los siguientes conceptos sobre punteros importantes podría aclarar a cualquier programador de C - 

| No | Concepto                           | Descripción                                                                         |
|----+------------------------------------+-------------------------------------------------------------------------------------|
|  1 | Puntero artimético                 | Hay 4 operadores ariméticos que pueden ser usado en punteros: ++, --, +, -          |
|  2 | Arrays de punteros                 | Podemos definir arrays para guardar un número de punteros                           |
|  3 | Punteros a punteros                | C permite tener un puntero en un puntero y así                                      |
|  4 | Pasando un puntero a una función   | Pasando un argumento por referencia o por dirección                                 |
|  5 | Devolviendo puntero de una función | C permite a una función devoler un puntero a una variable local guardada en memoria |
| |                                                                                     |

** Punteros aritméticos 

Un puntero en C es una dirección, la cual es un valor numérico. Además, podemos hacer operaciones matemáticas en punteros al igual que en valores numéricos. Hay cuatro operadores aritméticos que pueden ser usado en punteros: ++, --, + y - 

Para entender los punteros aritméticos, consideremos que *ptr* es un puntero entero el cual apunta a la dirección 100. Asumiendo enteros de 32-bits, vamos a ejecutar las siguiente operación aritmético en el puntero - 

: ptr++ 

Después de la operación anterior, el *ptr* apuntará a la dirección 1004 porque cada vez que ptr es incrementado, éste apuntará a la siguiente dirección entera la cual son 4 bytes más de la dirección actual. Esta operación moverá el puntero a la siguiente dirección de memoria sin impactar el verdadero valor a la dirección de memoria. Si *ptr* apunta a un carácter el cual tiene de dirección 1000, entonces la operación anterior apuntará a la dirección 1001 porque el próximo carácter disponible es el 1001

*** Incrementando un puntero 

Preferimos usar un puntero en nuestro programa en vez de un array porque la variable puntero puede ser incrementada, a diferencia del nombre del array el cual no puede ser incrementado porque es un puntero constante. El siguiente programa incrementa la variable puntero para acceder a cada elemento del array - 


#+BEGIN_SRC C

  #include <stdio.h>

  const int MAX = 3;

  int main(){

    int var[] = {10, 100, 200};
    int i, *ptr

      /* tenemos un puntero de array de direcciones */
      ptr = var;

    for( i = 0; i < MAX; i++){

      printf("Direccón de var[%d] = %x\n", i, ptr);
      printf("Valor de var[%d] = %d\n", i, *ptr);

      /* mover a la siguiente dirección */
      ptr++;

    }

    return 0;


  }

#+END_SRC


Cuando el código anterior es compilado y ejecutado, producirá
 el siguiente resultado - 

: Dirección de var[0] = bf882b30
: Valor de var[0] = 10
: Dirección de var[1] = bf882b34
: Valor de var[1] = 100
: Dirección de var[2] = bf882b38
: Valor de var[2] = 200

*** Decrementando un puntero 

Las mismas consideraciones se aplican a decrementar un puntero, el cual decrementa su valor por el número de bytes de su tipo de dato - 

#+BEGIN_SRC C

  #include <stdio.h>

  const int MAX = 3;

  int main(){

    int var[] = {10, 100, 200};
    int i, *ptr;

    /* vamos a usar array de direcciones en punteros */
    ptr = &var[MAX-1];

    for( i = MAX; i > 0; i--){

      printf("Dirección de var[%d] = %x\n", i-1, ptr);
      printf("Valor de var[%d] = %d\n", i-1, *ptr);

      /* nos movemos a la dirección anterior */
      ptr--;

    }

    return 0;

  }

#+END_SRC

Cuando el código anterior es compilado y ejecutado, producirá el siguiente código - 

: Dirección de var[2] = bfedbcd8
: Valor de var[2] = 200
: Dirección de var[1] = bfedbcd4
: Valor de var[1] = 100
: Dirección de var[0] = bfedbcd0
: Valor de var[0] = 10

*** Punteros de comparación

Los punteros pueden ser comparados por el uso de operadores relacionales, tales como ==, <, y >. Si p1 y p2 apuntan a variables que son relacionadas una a otra, tales como elementos del mismo array, entonces p1 y p2 pueden ser comparados. 

El siguiente programa modifica el ejemplo anterior - uno por incremento de la variable puntero así como la dirección a la cual apunta es menor o igual a la dirección del último elemento del array, es cual es &var[MAX -1] -

#+BEGIN_SRC C

  #include <stdio.h>

  const int MAX = 3;

  int main() {

    int var[] = {10, 100, 200};
    int i, *ptr;

    /* vamos a obtener la dirección del primer elemento */
    prtr = var;
    i = 0;

    while ( ptr <= &var[MAX - 1]) {

      printf("Dirección de var[%d] = %x\n", i, ptr);
      printf("Valor de var[%d] = %d\n", i, *ptr);

      /* apuntamos a la nueva localización */
      ptr++;
      i++;

    }

    return 0;

  }

#+END_SRC



Cuando el código anterior es compilado y ejecutado, producirá el siguiente código - 

: Dirección de var[0] = bfdbcb20
: Valor de var[0] = 10
: Dirección de var[1] = bfdbcb24
: Valor de var[1] = 100
: Dirección de var[2] = bfdbcb28
: Valor de var[2] = 200




** Arrays de punteros 

Antes de entender el concepto de arrays de punteros, vamos a considerar el siguiente ejemplo, el cual usa un array de 3 enteros - 

#+BEGIN_SRC C

  #include <stdio.h>

  const int MAX = 3;

  int main() {

    int var[] = {10, 100, 200};
    int i;

    for (i = 0; i < MAX; i++) {

      printf("Valor de var[%d] = %d\n", i, var[i]);

    }

    return 0;

  }


#+END_SRC


Cuando el código anterior es compilado y ejecutado, producirá el siguiente código - 

: Valor de var[0] = 10
: Valor de var[1] = 100
: Valor de var[2] = 200

Podría haber una situación donde queramos mantener un array, el cual puede guardar punteros a enteros o a caracteres o cualquier otro tipo de dato disponible. Siguiendo la declaración de un array de punteros a un entero - 

: int *ptr[MAX];

Esto declara a *ptr* como un array de punteros a enteros MAX. Además, cada elemento en ptr, mantiene un puntero a un valor entero. El siguiente ejemplo usa tres enteros, los cuales son guardados en una array de punteros - 

#+BEGIN_SRC C

  #include <stdio.h>

  const int MAX = 3;

  int main() {

    int var[] = {10, 100, 200};
    int i, *ptr[MAX];

    for ( i = 0; i < MAX; i++) {
      ptr[i] = &var[i]; /* asignamos la dirección del entero */
    }

    for (i = 0; i < MAX; i++) {
      printf("Valor de var[%d] = %d\n", i, *ptr[i]);
    }

    return 0;
  }

#+END_SRC


Cuando el código anterior es compilado y ejecutado, producirá el siguiente código - 

: Valor de var[0] = 10
: Valor de var[1] = 100
: Valor de var[2] = 200

Podemos usar también un array de punteros a caracteres para guardar una lista de cadena de caracteres de la forma que sigue - 

#+BEGIN_SRC C

  #include <stdio.h>

  const int MAX = 4;

  int main() {

    char *nombres[] = {
		       "Zara Ali",
		       "Hina Ali",
		       "Nuha Ali",
		       "Sara Ali"

    };

    int i = 0;

    for (i = 0; i < MAX; i++) {
      printf("Valor de nombres[%d] = %s\n", i, nombres[i] );
    }

    return 0;
  }

#+END_SRC

Cuando el código anterior es compilado y ejecutado, producirá el siguiente código - 

: Valor de nombres[0] = Zara Ali
: Valor de nombres[1] = Hina Ali
: Valor de nombres[2] = Nuha Ali
: Valor de nombres[3] = Sara Ali


** Puntero a puntero  

Un puntero a puntero es una forma de múltiple indirección, o una cadena de punteros. Normalmente, un puntero contiene la dirección de una variable. Cuando definimos un puntero a puntero, el primer puntero contiene la dirección del segundo puntero, el cual apunta a la locación que contiene el verdadero valor tal como lo mostramos. 


# imagen 

Una variable que es un puntero a puntero debe ser declarada como tal. Esto es hecho poniendo un asterisco adicional enfrente del nombre. Por ejemplo, la siguiente declaración declara un puntero aun puntero de tipo entero - 

: int **var;

Cuando un valor objetivo es indirectamente apuntado por un puntero a un puntero, accediendo que el valor requiere que el operador asterisco sea aplicado dos veces, tal como vemos en el siguiente ejemplo - 

#+BEGIN_SRC C

  #include <stdio.h>

  int main() {

int var;
int *ptr;
int **pptr;

var = 3000;

/* tomamos la dirección de var */
ptr = &var;

/* tomamos la dirección de ptr usando la dirección del operador & */
pptr = &ptr;

/* tomamos el valor usando pptr */
printf("Valor de var = %d\n", var);
printf("Valor disponible en *ptr = %d\n", *ptr);
printf("Valor disponible en **pptr = %d\n", **pptr);

return 0;

  }

#+END_SRC


Cuando el código anterior es compilado y ejecutado, producirá el siguiente código - 

: Valor de var = 3000
: Valor disponible en *ptr = 3000
: Valor disponbiel en **pptr = 3000

** Pasando punteros a funciones 


C permite pasar un puntero a una función. Para hacer esto, simplemente  declara los parámetros de la función como un tipo puntero. 

Lo siguiente es un simple ejemplo donde pasamos un puntero largon sin signo a una función y cambiamos el valor dentro de la función el cual refleja en la llamada de la función - 

#+BEGIN_SRC C

  #include <stdio.h>
  #include <time.h>

  void getSeconds(unsigned long *par);

  int main(){

    unsigned long sec;
    getSeconds( &sec );

    /* escribe el valor verdadero */
    printf("Número de segundos: %ld\n", sec);

    return 0

      }

  void getSeconds(unsigned long *par){
    /* obtener el número actual de segundos */
    ,*par = time( NULL );
    return;

  }

#+END_SRC

Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado - 

: Nümero de segundos: 1294450468

La función, la cual puede aceptar un puntero, puede también aceptar un array como muestra el siguiente ejemplo - 


#+BEGIN_SRC C

  #include <stdio.h>

  /*  declaración de funciones */
  double obtenerMedia(int *arr, int tamaño);

  int main() {

    /* un array de enteros con 5 elementos */
    int balance[5] = {1000, 2, 3, 17, 50};
    double avg;

    /* pasamos el puntero al array como argumento */
    avg = obtenerMedia( balance 5 );

    /* salida del valor devuleto */
    printf("El valor medio es: %f\n", avg);
    return 0;

  }

  double obtenerMedia(int *arr, int tamaño){

    int i, sum = 0;
    double avg;

    for (i = 0; i < size; i++) {
      sum += arr[i];
    }

    avg = (double)sum/ tamaño;
    return avg;
  }

#+END_SRC

Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado - 

: El valor medio es: 214.40000

** Devolviendo puntero desde funciones en C

Hemos visto en el último capítulo como C permite devolver un array desde una función. Similarmente, C también permite devovler un puntero desde una función. Para hacer esto, debemos declarar una función devolviendo un puntero como en el siguiente ejemplo - 

#+BEGIN_SRC C

    int * miFuncion(){
      .
      .
      .

    }

#+END_SRC


El segundo punto a recordar es que, no es buena idea devolver una dirección de una variable local fuera de la función, así tendriamos que definir la variable local como un variable *estática*. 

Ahora, vamos a considerar la siguiente función la cual genera 10 número aleatorios y los devuelve usando un array el cual representa un puntero, es decir, la dirección del primer elemento del array. 

#+BEGIN_SRC C

  #include <stdio.h>
  #include <time.h>

  /* función para generar y devolver números aleatorios */
  int * obtenerAleatorios(){

    static int r[10];
    int i;

    /* establecer la semilla */
    srand( (unsigned)time( NULL ) );

    for ( i = 0; i < 0; ++i) {
      r[i] = rand();
      printf("%d\n", r[i] );
    }

    return r;

  }

  /* función principal que llama la función antes definida */
  int main(){

    /* un puntero a un entero */
    int *p;
    int i;

    p = obtenerAleatorios();

    for ( i = 0; i < 10; i++) {
      printf("*(p + [%d) : %d\n", i *(p + i) );
    }

    return 0;

  }


#+END_SRC


Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado - 


: 1523198053
: 1187214107
: 1108300978
: 430494959
: 1421301276
: 930971084
: 123250484
: 106932140
: 1604461820
: 149169022
: *(p + [0]) : 1523198053
: *(p + [1]) : 1187214107
: *(p + [2]) : 1108300978
: *(p + [3]) : 430494959
: *(p + [4]) : 1421301276
: *(p + [5]) : 930971084
: *(p + [6]) : 123250484
: *(p + [7]) : 106932140
: *(p + [8]) : 1604461820
: *(p + [9]) : 149169022

* C - Cadenas de texto 

Las cadenas de texto son arrays unidimensionales de caracteres terminados por un carácter *null* '\0'. Además una cadena de texto null-terminada contiene los caracteres que comprenden la cadena de texto seguido por un *null*. 

La siguiente declaración e inicialización crea una cadena de caracteres consistenten en la palabra "Hola". Para mantener el carácter null al final del array, el tamaño del array de caracteres que contiene la cadana de caracters es uno más que el número de caracteres de la palabra "Hola". 

: char saludo[4] ={'H', 'o', 'l', 'a', '\0'};

Si seguimos la regla de inicialización de los arrays entonces podemos escribir la declaración anterior de la siguiente forma 

: char saludo[4] = "Hola";

Lo siguiente es la representación de memoria de lo anterior definido en C/C++


# imagen 

Realmente, no se pone el carácter /null/ al final de una cadena de texto constante. El compilador C automáticamente lo hace cuando se inicializa el array. Veamos este ejemplo 


#+BEGIN_SRC C

  #include <stdio.h>

  int main() {

    char saludo[4] = {'H', 'o', 'l', 'a', '\0'};
    printf("Mensaje de saludo: %s\n", saludo);
    return 0;

  }

#+END_SRC

Cuando el código anterior sea compilado y ejecutado, mostrará el siguiente resultado -

: Mensaje de saludo: Hola

C soporta un amplio rango de funciones para manipular cadenas de texto terminadas en null 

| No | Función       | Propósito                                                 |
|----+---------------+-----------------------------------------------------------|
|  1 | strcpy(s1,s2) | Copiar la cadena s2 en s1                                 |
|  2 | strcat(s1,s2) | Concatenar la cadena s2 en s1                             |
|  3 | strlen(s1 )   | Devuelve la longitud de s1                                |
|  4 | strcmp(s1,s2) | Devuelve 0 s1 y s2 son iguales. -0 si s1< s2; +0 si s1>s2 |
|  5 | strchr(s1,ch) | Devuelve un puntero a la primera ocurrencia de ch en s1   |
|  6 | strstr(s1,s2) | Devuelve un puntero a la primera ocurrencia de s2 en s1   |


El siguiente ejemplo usa algunos de las funciones antes mencionadas 


#+BEGIN_SRC C

  #include <stdio.h>
  #include <string.h>

  int main(){

    char str1[12] = "Hello";
    char str2[12] = "World";
    char str3[12];
    int len;

    /* copiar str1 en str3 */
    strcpy(str3, str1);
    printf("strcpy( str3, str1): %s\n", str3);

    /* concatenar str1 y str2 */
    strcat(str1, str2);
    printf("strcat(str1, str2): %s\n", str1);

    /* longitud total de str1 después de la concatenación */
    len = strlen(str1);
    printf("strlen(str1) : %d\n", len);

    return 0;


  }


#+END_SRC


Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado -


: strcpy( str3, str1) :  Hello
: strcat( str1, str2):   HelloWorld
: strlen(str1) :  10

* C - Estructuras 

Los arrays nos permiten definir tipos de variables que pueden guardar varios tipos de datos del mismo tipo. Similarmente las *estructuras* es otro tipo de dato definido por el usuario disponible en C que permite combinar elementos de distintos tipos de datos. 

Las estructuras son usadas para representar un registro. Supongamos que queremos  guardar los registros de libros en una biblioteca. Podríamos querer seguir los siguientes atributos de cada libro - 

: * Titulo
: * Autor
: * Asignatura
: * ID del libro

** Definiendo una estructura 

Para definir una estructura, debemos usar la declaración *struct*. La declaración *struct* define un nuevo tipo de dato, con más de un miembro. El formato de la declaración struct es el siguiente 

#+BEGIN_SRC C

  struct [etiquetas de la estructura] {

    definición del miembro;
    definición del miembro;
    ...
      definición del miembro;

  } [una o más variables de la estructura]


#+END_SRC

La *etiqueta de la estructura* es opcional y cada definición del miembro es una definición normal de variable, tal como int i; o float f; o cualquier otro tipo de definición de variable válida. Al final de la definición de la estructura, antes del punto y como final, podemos especificar una o más variables de la estructura pero es opcional. 

Aquí vamos a ver como declararíamos la estructura Libro - 

#+BEGIN_SRC C

  struct Libros{
    char titulo[50];
    char autor[50];
    char asignatura[100];
    int id_libro;
  } libro;

#+END_SRC

** Accediendo a los miembros de la estructura 

Para acceder a cualquier miembro de una estructura, usamos el *operador para acceso a miembros (.)*. Este operador es codeado como un periodo entre el nombre de la estructura y los miembros a los que queremos acceder. Podríamos usar la palabra clave *struct* para definir variables del tipo estructura. El siguiente ejemplo nos muestra como usar una estructura en un programa - 

#+BEGIN_SRC C

  #include <stdio.h>
  #include <string.h>

  struct Libros {
    char titulo[50];
    char autor[50];
    char asignatura[100];
    int libro_id;
  };

  int main(){

    struct Libros Libro1;    /* Declaramos Libro1 como un tipo de Libro */
    struct Libros Libro2;

    /* especificaciones del libro 1 */
    strcpy( Libro1.titulo, "C Programming");
    strcpy( Libro1.autor, "Nuha Ali");
    strcpy( Libro1.asignatura "C programming Tutorial");
    Libro1.libro_id = 6495407;

    /* especificaciones del libro 2 */
    strcpy( Libro2.titulo, "Telecom Billing");
    strcpy( Libro2.autor, "Zara Ali");
    strcpy( Libro2.asignatura, "Telecom Billing Tutorial");
    Libro2.libro_id = 6495700;

    /* mostrando la información del libro 1 */
    printf( "Titulo Libro 1: %s\n", Libro1.titulo);
    printf( "Autor Libro 1: %s\n", Libro1.autor);
    printf( "Asignatura Libro 1: %s\n", Libro1.asignatura);
    printf( "ID del Libro 1: %d\n", Libro1.libro_id);

    /* mostrando la información del libro 2 */
    printf( "Titulo Libro 2: %s\n", Libro2.titulo);
    printf( "Autor Libro 2: %s\n", Libro2.autor);
    printf( "Asignatura Libro 2: %s\n", Libro2.asignatura);
    printf( "ID del Libro 2: %d\n", Libro2.libro_id);

    return 0;

  }


#+END_SRC


Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado 


** Estructuras como argumentos de funciones 

Podemos pasar estructuras como argumentos de funciones de la misma forma en la que le pasamos cualquier otra variable o punteros. 


#+BEGIN_SRC C

  #include <stdio.h>
  #include <string.h>

  struct Libros {
    char titulo[50];
    char autor[50];
    char asignatura[100];
    int libro_id;
  };

  /* declaración de la función */
  void imprimirLibro ( struct Libros libro);

  int main() {

    struct Libros Libro1;   /* Declaramos Libro1 como un tipo de Libro */
    struct Libros Libro2;

    /* especificaciones de libro 1 */
    strcpy( Libro1.titulo, "C Programming");
    strcpy( Libro1.autor, "Nuha Ali");
    strcpy( Libro1.asignatura, "C Programming Tutorial");
    Libro1.libro_id = 6495407;

    /* especificaciones de libro 2 */
    strcpy( Libro2.titulo, "Telecom Billing");
    strcpy( Libro2.autor, "Zara Ali");
    strcpy( Libro2.asignatura, "Telecom Billing Tutorial");
    Libro2.libro_id = 6495700;

    /* mostrar información del Libro 1 */
    imprimirLibro( Libro1 );

    /* mostrar información del Libro 2 */
    imprimirLibro ( Libro2 );

    return 0;

  }

  void imprimirLibro ( struct Libros Libro) {

    printf("Titulo del Libro: %s\n", libro.titulo);
    printf("Autor del libro: %s\n", libro.autor);
    printf("Asignatura del libro: %s\n", libro.asignatura);
    printf("Id del libro: %d\n", libro.libro-id);

  }


#+END_SRC

Cuando compilemos y ejecutemos el código anterior, resultará el siguiente código - 





** Punteros a estructuras 

Podemos definir punteros a estructuras de la misma forma que definimos un puntero a cualquier otra variable - 

: struct Libros *struct_pointer;

Ahora, podemos guardar la dirección de una estructura en el siguiente puntero. Para encontrar la dirección de una estructura, pondremos el operador '&' antes del nombre de la estructura de la siguiente manera - 

: struct_pointer = &Libro1;

Para acceder a los miembros de una estructura usando un puntero a esa estructura, debemos usar el operador -> de la siguiente manera - 

: struct_pointer->titulo;

Vamos a reescribir el ejemplo anterior usando punteros - 


#+BEGIN_SRC C

  #include <stdio.h>
  #include <string.h>

  struct Libros {
    char titulo[50];
    char autor[50];
    char asignatura[100];
    int id_libro;

  };

  /* declaración de función */
  void imprimirLibro( struct Libros *libro);
  int  main(){


    struct Libros Libro1;  /* Declaramos Libro1 como un tipo de Libro */
    struct Libros Libro2;

    /* especificación de libro 1 */
    strcpy( Libro1.titulo, "C Programming");
    strcpy( Libro1.autor, "Nuha Ali");
    strcpy( Libro1.asignatura, "C Programming Tutorial");
    Libro1.libro_id = 6495407;

    /* especificación de libro 2 */
    strcpy( Libro2.titulo, "Telecom Billing");
    strcpy( Libro2.autor, "Zara Ali");
    strcpy( Libro2.asignatura, "Telecom Billing Tutorial");
    Libro2.libro_id = 6495700;

    /* muestra la ifnormación de Libro 1 pasando la dirección de libro 1 */
    imprimirLibro( &Libro1 );

    /* muestra la información de Libro2 pasando la dirección de Libro 2 */
    imprimirLibro( &Libro2 );

    return 0;

  }

  void imprimirLibro( struct Libros *libro ){

    printf("Título del libro: %s\n", libro->titulo);
    printf("Autor del libro: %s\n", libro->autor);
    printf("Asignatura del libro: %s\n", libro->asignatura);
    printf("Id del libro: %d\n", libro->libro_id);

  }

#+END_SRC

** Campos Bit

Los campos bit nos permite el empaquetado de datos en una estructura. Esto es especialmente útil cuando la memoria o el guardado de datos premian. Los típicos ejemplos incluyen - 

+ Empaquetar varios objetos en una palabra máquina, por ejemplo, un bit bandera que puede ser compactado.

+ Leyendo formatos de fichero externos -- formatos de fichero no estándar pueden ser leídos, por ejemplo, enteros de 9-bit.

C permite hacer esto en una definición de estructura poniendo la longitud del bit después de la variable. Por ejemplo 

#+BEGIN_SRC C

  struct estructura_empaquetada {
    unsigned int f1:1;
    unsigned int f2:1;
    unsigned int f3:1;
    unsigned int f4:1;
    unsigned int type:4;
    unsigned int my_int:9:
  } paquete;


#+END_SRC

Aquí la estructura empaquetada contiene 6 miembros: 4 banderas de 1 bit f1..f3, 4-bit type y 9-bit my_int.

C automáticamente empaqueta los siguientes campos de bits tan compactos como sea posible, proporcionando que la máxima longitud de campo sea menor o igual que la longitud de una palabra entera de la computadora. En este caso, algunos compiladores pueden permitir que la memoria se colapse para los campos mientras otros campos se guardarán en la siguiente palabra. 

* C - Uniones 

Una *unión* es un tipo especial de dato en C que permite guardar diferentes tipos de datos en la misma dirección de memoria. Podemos definir una unión con  muchos miembros, pero solo un miembro puede contener un valor en un tiempo dado. Las Uniones proporcionan un forma eficiente de usar la misma dirección de memoria para diferentes propósitos.

** Definiendo una Unión 

Para definier una unión, se debe usar la declaración *union* de la misma forma que hemos hecho para definir una estructura. La declaración unión define un nuevo tipo de dato con más de un miembro para tu programa. El formato de la declaración de la unión es el siguiente - 

#+BEGIN_SRC C

union [ etiqueta union] {
miembro definición;
miembro definición;
...
miembro definición;
} [ una o más variables de unión]

#+END_SRC


La *etiqueta unión* es opcional y cada definición de miembro es una definicióln normal de variable, tal como un entero, un punto flotante, o cualuqier otra variable válido. Al final de la definición de unión, antes del punto y coma, podemos especiar una o más variables de unión pero también es opcional. Aquí vemos  la forma en la que podemos definir un tipo de Dato Unión con tres miembros - 

#+BEGIN_SRC C

  union Data {
    int i;
    float f;
    char str[20];
  } data;

#+END_SRC

Ahora, la variable *Data* puede guardar un entero, un coma flotante o una cadena de caracteres. Esto significa qeu una sola variable, es decir, la misma dirección de memoria, puede ser usada para guardar múltiples tipos de datos. Podemos usar cualquier tipo de tipo de dato definido por el usuario dentro de una unión con nuestros propios requerimientos. 

La memoria ocupada por una unión será lo suficientemente grande para guardar el miembro mayor de la unión. Por ejemplo, en el ejemplo anterior, el tipo Data ocupará 20 bytes de memoria poruqe es el máximo necesario que necesita ocupar una cadena de caracteres. El siguiente ejemplo muestra la memoria total ocupada por la unión anterior. - 

#+BEGIN_SRC C

  #include <stdio.h>
  #include <string.h>

  union Data {
    int i;
    float f;
    char str[20];
  };

  int main(){

    union Data data;

    printf(" El tamaño de memoria usado por data es: %d\n", sizeof(data));

    return 0;

  }


#+END_SRC


Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado - 

: El tamaño de memoria usado por data es: 20

** Accediendo a los miembros de la Unión

Para acceder a cualquier miembro de la unión, usaremos el *operador para acceso a miembos (.)*. Este operador es un punto entre el nombre de la unión y el nombre del miembro de la unión al cual queremos acceder. Veamos el siguiente ejemplo - 

#+BEGIN_SRC C

  #include <stdio.h>
  #include <string.h>

  union Data {
    int i;
    float f;
    char str[20];
  };

  int main(){

    union Data data;

    data.i = 10;
    data.f = 220.5;
    strcpy( data.str, "C Programming");

    printf( "data.i : %d\n", data.i);
    printf( "data.f : %f\n", data.f);
    printf( "data.str : %s\n", data.str);

    return 0;

  }

#+END_SRC


Cuando compilemos y ejecutemos el código anterior, se producirá el siguiente resultado - 

: data.i : 1917853763
: data.f : 4122360580327794860452759994368.000000
: data.str : C Programming

Aquí, podemos ver que el valor de los miembros *i* y *f* de la unión están corrompidos porque el valor final asignado a la variable ha ocupado la dirección de memoria y esta es la razón por la que le valor del miembro *str* está dibujado bien.

Ahora veamos el mismo código en el cual usaremos una variable a la vez con el mismo propósito de tener uniones - 

#+BEGIN_SRC C

  #include <stdio.h>
  #include <string.h>

  union Data {
    int i;
    float f;
    char str[20];
  };

  int main(){

    union Data data;

    data.i = 10;
    printf( "data.i : %d\n", data.i);

    data.f = 220.5;
    printf( "data.f : %f\n", data.f);

    strcpy( data.str, "C Programming");
    printf( "data.str : %s\n, data.str");

    return 0;


  }



#+END_SRC

Cuando compilemos y ejecutemos el código anterior, este producirá el siguiente resultado - 

: data.i : 10
: data.f : 220.500000
: data.str : C Programming

Aquí, todos los miembros están bien escritos porque cada miembro ha sido usado a la vez. 
* C - Campos Bit 

Supongamos que nuestro programa C contiene un número de variables VERDADERO/FALSO agrupadas en una estructura llamada estatus de la siguiente manera - 

#+BEGIN_SRC C

  struct {
    unsigned int anchuraValidada;
    unsigned int alturaValidada;
  } estatus;


#+END_SRC

Esta estrucutura requiere 8 bytes de memoria pero en realidad, vamos a guardar entre 0 y 1 en cada variable. C ofrece una mejor forma de usar el espacio de memoria en estas situaciones. 

Si hemos usando estas variables dentro de una estructura entonces podemos definir la anchura de una variable diciéndole al compilador que vamos a usar solo esos cantidad de bytes. Por ejemplo, vamos a escribir la estructura anterior. 

#+BEGIN_SRC C

  struct {
    unsigned int anchuraValidadad : 1;
    unsigned int alturaValidada : 1;
  } estatus;



#+END_SRC

La estructura anterior requiere 4 bytes de memoria para la variable estatus, pero solo 2 bits serán usados. 

Si usamos 32 variables cada una con una anchura de 1 bit, entonces también la estructura usará 4 bytes. Sin embargo, tan pronto como tengamos 33 variables, será localizada en el siguiente slot de memoria y empezará a usar 8 bytes. Veamos el siguiente ejemplo y entendamos el concepto - 

#+BEGIN_SRC C

  #include <stdio.h>
  #include <string.h>

  /*  definiendo una simple estructura */
  struct {
    unsigned int anchuraValidada;
    unsigned int alturaValidada;
  } estatus1;

  /* definiendo una estructura con campos bit */
  struct {
    unsigned int anchuraValidada : 1;
    unsigned int alturaValidada : 1;
  } estatus2;

  int main(){
    printf("La memoria usada por estatus1 es: %d\n", sizeof(estatus1));
    printf("La memoria usada por estatus2 es: %d\n", sizeof(estatus2));
    return 0;
  }

#+END_SRC

Cuando compilemos y ejecutemos el código anterior, se producirá el siguiente resultado - 

: La memoria usada por estatus1 es : 8
: La memoria usada por estatus2 es : 4


** Declaración de Campos Bit

La declaración de un campo bit tiene la siguiente forma dentro de una estructura - 

#+BEGIN_SRC C

  struct {
    tipo [nombre_miembro] : anchura;
  };

#+END_SRC


La siguiente tabla describe los elementos variables de un campo bit 

| No | Elemento       | Descripción                                                                      |
|----+----------------+----------------------------------------------------------------------------------|
|  1 | tipo           | Un tipo entero que determina como el valor será interpretado                     |
|  2 | nombre_miembro | El nombre del campo bit                                                          |
|  3 | anchura        | El número de bits del campo bit. Debe ser menor o igual que el tipo especificado |


Las variables definidas con una anchura predefinida  son llamadas *campos bit* . Un campo bit puede mantener más de un único bit; por ejemplo, si necesitamos una variable que guarde un valor de 0 a 7,entonces podemos deifnir un campo bit con una anchura de 3 bits como sigue - 

#+BEGIN_SRC C

    #include <stdio.h>
    #include <string.h>

    struct {
  unsigned int edad : 3;
    } Edad;

  int main(){

Edad.edad = 4;
printf("Tamaño de (Edad): %d\n", sizeof(Edad));
printf ("Edad.edad : %d\n", Edad.edad);

Edad.edad = 7;
printf ("Edad.edad : %d\n", Edad.edad);

Edad.edad = 8;
printf ("Edad.edad : %d\n", Edad.edad);

return 0;
  }

#+END_SRC

Cuando compilemos y ejecutemos el código anterior, mostrará una advertencia y producirá el siguiente resultado - 

: Tamaño de (Edad): 4
: Edad.edad = 4
: Edad.edad = 7
: Edad.edad = 0
* C - Typedef

C proporciona una palabra clave llamada *typedef*, la cual puede usarse para darle un nuevo tipo de nombre. El siguiente ejemplo define un termino *BYTE*  para un número de un byte. 

: typedef unsigned char BYTE;

Después de este tipo de definición, el identificador BYTE puede ser usado como una abreviación para el tipo *unsigned char*, por ejemplo 

: BYTE b1, b2;

Por convención, las palabras en mayúsculas son usadas para esas definiciones para recordar al usuario que el nombre del tipo es en realidad una abrevicación simbólica, pero se puede poner en minúscula, como sigue - 

: typedef unsigned char byte; 

Se puede usar *typedef* para darle el nombre a un tipo definido por el usuario también. Por ejemplo, podemmos usar typedef con una estructura para definir un nuevo tipo de datos y entonces usar ese tipo de datos para definir estructuras directamente de la siguiente manera - 


#+BEGIN_SRC C

  #include <stdio.h>
  #include <string.h>

  typedef struct Libros {
    char titulo[50];
    char autor[50];
    char titulo[50]
    char asignatura[100];
    int id_libro;
  } Libro;

  int main(){

    Libro libro;

    strcpy( libro.titulo, "C Programming");
    strcpy( libro.autor, "Muha Ali");
    strcpy( libro.asignatura, "C Programming tutorial");
    book.id_libro = 6495407;

    printf( "Titulo libro: %s\n", libro.titulo);
    printf( "Autor libro: %s\n", libro.autor);
    printf( "Asignatura libro: %s\n", libro.Asignatura);
    printf( "Id del libro : %d\n", libro.id_libro);

    return 0;

  }

#+END_SRC


Cuando compilemos y ejecutemos el código anterior, éste producirá el siguiente resultado - 

: Titulo libro: C Programming
: Autor libro: Nuha Ali
: Asignatura libro: C Programming Tutorial
: Id del libro: 6495407

** typedef vs #define 
* C - Entrada y Salida 

Cuando uno dice *Entrada*, significa alimentar con datos al programa. Una entrada puede ser dada en la forma de un archivo o desde un comando en línea. C  proporciona un conjunto de funciones para leer entradas y alimentarlas al programar cuando sean requeridas. 

Cuando uno dice *Salidas*, significa mostrar algunos de esos datos en pantalla, impresora o en cualquier archivo. C proporciona un conjunto de funciones para la salida de datos en la pantalla de la computadora al igual que para salvarlos en un archivo de texto o binario. 

** Archivos estándar 

C trata todos los dispositivos como archivos. Así dispositivos tale como pantallas son direccionados de la misma forma que un archivo y los siguientes tres archivos son automáticamente abiertos cuando un programa ejecutado proporcional acceso al teclado y la pantalla. 

| Archivo estándar | Archivo al que apunta | Dispositivo |
|------------------+-----------------------+-------------|
| Entrada estándar | stdin                 | Teclado     |
| Salidas estándar | stdout                | Pantalla    |
| Error estándar   | stderr                | Tu pantalla |

Los archvios al que apunta son los principales para acceder al archivo con propósito de lectura y escritura. Esta sección explica como se leen los valores desde la pantalla y como se imprime los resultados en la pantalla. 

** Funciones getchar() y putchar()


La función *getchar(void) entero*  lee el siguiente carácter disponible de la pantalla y lo devuelve como un entero. Esta función lee solo un carácter a la vez. Podemos usar este método en bucle en caso de que querer leer más de un carácter de la pantalla. 

La función *entero putchar(entero c)* pone el carácter pasado en la pantalla y devuelve el mismo carácter. Esta función pone solo un carácter a la vez. Podemos usar este método en bucle en el caso de que queramos mostrar más de un carácter  en la pnatalla. Veamos el siguiente ejemplo.

#+BEGIN_SRC C

  #include <stdio.h>
  int main(){

    int c;

    printf( "Introduce un valor: ");
    c = getchar();

    printf( "\nHas introducido: ");
    putchar( c );

    return 0;
  }

#+END_SRC 


Cuando el código anterior sea compilado y ejecutado, esperará a que escribas algún texto. Cuando introduzcas un texto y presiones enter, entonces el programa procederá a leer solo un carácter y mostrarlo de la siguiente forma - 


: $./a.out
: Introduce un valor: esto es un texto
: Has introducido:  t

** Las funciones gets() y puts()

La función *char gets(char \*s)* lee una línea desde *stdin* en el buffer apuntado desde la *s* hasta la aparición de una nueva línea o un EOF(Fin de Fichero).

La función *int puts(const char \*s)* escribe la cadena 's' y 'a'. 

*NOTA*: gets ya es una función obsoleta. En vez de usar gets, se usará *fgets()*. 

#+BEGIN_SRC C

  #include <stdio.h>
  int main(){

    char str[100];

    printf( "Introduce un valor: ");
    gets( str );

    printf("\nHas introducido: ");
    puts( str );

    return 0;

  }


#+END_SRC

Cuando compilemos y ejecutemos el código anterior, e introduzcamos un texto, esto mostrará - 


: $./a.out
: Introduce un valor: esto es un texto
: Has introducido: esto es un texto

*** La función fgets()

la función de C *char \*fgets(char \*str, int n, FILE \*stream)* lee una línea dentro de un específico flujo y lo guarda en la cadena de caracteres apuntada por *str*. Se para cuando cualquier *(n-1)* caracteres son leídos, el carácter de nueva línea es leído, o se alcanza el final del archivo, lo que llegue primero. 

**** Declaración

La siguiente declaración para la función fgets() es como sigue - 

: char *fgets(char *str, int n, FILE *stream)

**** Parámetros 

+ *str* - Este es el puntero a un array de caracteres donde la cadena leída es guardada

+ *n* - Este es el máximo número de caracteres para ser leídos (incluyendo el carácter final null). Normalmente, la longitud del array pasado como str es usado. 

+ *stream* - Este es el puntero a un archivo objeto que identifica el flujo desde donde los caracteres son leídos. 

**** Valor de retorno 

En éxito, la función devuelve el mismo parámetro str. Si el final del archivo es encontrado y ningún carácter ha sido leído, el contenido de str se mantendrá sin cambios y el puntero null será devuelto. 

Si un error ocurre, un puntero null será devuelto. 



**** Ejemplo 


El siguiente ejemplo muestra el uso de la función fgets()


#+BEGIN_SRC C

  #include <stdio.h>

  int main(){
    FILE *fp;
    char str[60];

    /* abriendo el archivo para lectura */
    fp = fopen("file.txt", "r");
    if(fp == NULL){
      perror("Error abriendo archivo");
      return(-1);
    }
    if( fgets (str, 60, fp)!=NULL) {
      /* escribiendo el contenido de stdout */
      puts(str);
    }
    fclose(fp);

    return(0);
  }

#+END_SRC


Si asumimos que tenemos un archivo de texto *file.txt* con el contenido "Estamos en el año 2020", cuando compilemos y ejecutemos el código anterior obtendremos el siguiente resultado - 

: Estamos en el año 2020


** Las funciones scanf() y printf() 

La función *int scanf(const char \*format, ...)* lee la entrada desde el flujo de la entrada estándar *stdin* y escanea la entrada acorde con el *formato* proporcionado. 
L función *int printf(const char \*format, ..)* escribe la salida al flujo de la salida estándar *stdout* y produce la salida acorde con el formato proporcionado. 

El *formato* puede ser un simple cadena de caracteres constantes, pero podemos especificar %s, %d, %c, %f, etc, para imprimir o leer cadenas de caracteres, enteros, caracteres, o coma flotante respectivamente. Hay muchos otros formatos disponibles los cuales puede ser usados según la necesidad. Vamos a proceder con un ejemplo simple para entender el concepto mejor - 


#+BEGIN_SRC C

  #include <stdio.h>
  int main(){

    char str[100];
    int i;

    printf( "Introduce un valor: ");
    scanf("%s %d, str, &i");

    printf( "\nHas introducido: %s %d", str, i);

    return 0;


  }

#+END_SRC


Una vez compilado y ejecutado el código anterior e introducido algún texto, esto producirá  - 


: $./a.out
: Introduce un valor: siete 7
: Has introducido: siete 7

* C - Entrada/Salida de Archivos 

En el último capítulo hemos explicado los dispositivos estándares de entrada y salida manejados por C. En este capítulo cubriremos el cómo C puede crear, abrir y cerrar ficheros de texto y binarios para su guardado. 

Un archivo representa una secuencia de bytes, a pesar de un fichero de texto o binario. C proporciona acceso a funciones de alto nivel al igual que de bajo nivel (nivel de Sistema Operativo) para manejar los ficheros en los dispositivos de guardado. En este capítulo veremos a través de importantes llamadas para manejar archivos. 

** Abriendo archivos 


Podemos usar la función *fopen()* para crear un nuevo archivo o abrir uno existente. Esta llamada inicializará un objeto el tipo *FILE*, el cual contiene toda la información necesaria para controlar el flujo. El prototipo de esta llamada a fucnión es como sigue - 

: FILE *fopen( const char * filename, const char * mode);

Aquí, *filename* es una cadena literal, la cual usará el nombre del fichero, y el *modo* de acceso puede tener uno de los siguiente valores - 

| Nº | Modo | Descripción                                                                            |
|----+------+----------------------------------------------------------------------------------------|
|  1 | r    | Abre un archivo existente para lectura                                                 |
|  2 | w    | Abre un archivo existente para escritura. Si no existe lo crea                         |
|  3 | a    | Abre un archivo para escritura en modo añadir. Si no existe lo crea                    |
|  4 | r+   | Abre un archivo para lectura y escritura                                               |
|  5 | w+   | Abre un archivo para lectura y escritura. Si existe lo trunca a cero sino lo crea.     |
|  6 | a+   | Abre un archivo para lectura y escritura. Si no exite lo crea y lo abre en modo añadir |

Si vamos a manejar archivos binarios, entonces usaremos los siguientes modos de acceso en de los mencionados antes - 

"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"


** Cerrando un archivo 

Para cerrar un archivo, usamos la función fclose(). El prototipo de esta función es - 

: int fclose( FILE *fp );

La función *fclose(-)* devuelve cero si hay éxito, o *EOF* si hay algún error cerrando el archivo. Esta función realmente graba cualquier dato que todavía esté pendiente en el buffer en el fichero, cierra el fichero, y actualiza cualquier memoria usada en el fichero. El EOF es  una constante definida en la cabecera del archivo stdio.h 

Hay varias funciones proporcionadas por la biblioteca estándar de C para leer y escribir un archivo, carácter por carácter, o en la forma de un cadena de longitud fija. 

** Escribiendo un archivo 

La siguiente es la forma más sencilla para escribir un carácter individual en un flujo - 

: int fputc(int c, FILE *fp);

La función *fputc()* escribe el valor del carácter del argumento c y lo pone en el flujo de salida referenciado por fp. Esto devuelve el carácter escrito si hay éxito y EOF si hay algún error. Podemos usar la siguiente función para escribir una cadena null terminada a un flujo - 

: int fputs( const char *s, FILE *fp);

La función *fputs* escribe el valor carácter s al flujo de salida referenciado por fp. Si devuelve un valor no negativo si hay éxito, en cambio devolverá EOF en caso de error. Podemos usar la función *int fprint(FILE *fp,const char *format, ...)* también para escribir una cadena en un archivo. Veamos el siguiente ejemplo: 


Vamos a asegurarnos primero que tenemos un directorio */tmp*. Si no, deberemos crearlo. 

#+BEGIN_SRC C

  main(){
    FILE *fp;

    fp = fopen("/tmp/test.txt", "w+");
    fprintf(fp, "Esto es una prueba para fprintf...\n");
    fputs("Esto es una prueba para fputs...\n", fp);
    fclose(fp);
  }

#+END_SRC

Cuando el código anterior sea compilado y ejecutado, creará un nuevo archivo *test.txt* en el directorio /tmp y escribirá dos líneas usando las dos funciones distintas. Vamos a leer el archivo en la siguiente sección.

** Leyendo un archivo 

Lo siguiente es la función más sencilla para un solo carácter desde un archivo - 

: int fgetc( FILE * fp);

La función *fgetc()* lee un carácter desde el fichero de entrada referenciado por fp. El valor de vuelta es el carácter leído, o en caso de algún error, devolverá *EOF*. La siguiente función permite leer una cadena desde un flujo - 

: char *fgets( char *buf, int n, FILE *fp);

La función *fgets()* lee un n-1 carácter desde el flujo de entrada referenciado por fp. Éste copia la cadena leída en el buffer *buf*, y añade un carácter *null* al terminar la cadena.

Si esta función encuentra un carácter de salto de línea '\n' o el final del archivo antes de que se haya leído el máximo de caracteres , entonces solo devolverá los caracteres leídos hasta ese momento. Podemos usar también la fucnión *int fscan(FILE *fp, const char *format, ...)* para leer cadenas desde un archivo, pero dejará de leer  después de encontrar el primer caracter de espacio.


#+BEGIN_SRC C

  #include <stdio.h>

  main(){

    FILE *fp;
    char buff[255];

    fp = fopen("/tmp/test.txt", "r");
    fscanf(fp, "%s", buff);
    printf("1 : %s\n", buff);

    fgets(buff, 255, (FILE*)fp);
    printf("2: %s\n", buff);

    fgets(buff, 255, (FILE*)fp);
    printf("e: %s\n", buff);
    fclose(fp);

  }



#+END_SRC

Cuando el código anterior sea compilado y ejecutado, leerá el archivo creado en la sección anterior y producirá el siguiente resultado - 

: 1: Esto
: 2: es una prueba para fprintf...

: 3: Esto es una prueba para fputs...

Vamos a ver un poco más en detalle lo que ha ocurrido aquí. Primero, *fscanf()* lee solo *Esto* porque después de eso, encuentra un espacio, la segunda llamada es para *fgets()* el cual lee el resto de la línea hasta encontrar un fin de línea. Finalmente, la ultima llamada *fgets()* lee la segunda línea completamente. 


** Funciones Binarias de Entrada/Salida

Hay dos funciones, que pueden ser usadas para la entrada y salida binaria - 

: size_t fread(void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);
              
: size_t fwrite(const void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);

Ambas funciones pueden ser usadas para leer o escribir bloques de memoria - normalmente arrays o estructuras.

* C - Preprocesadores


Los *Preprocesadores de C* no son parte del compilador, pero es un paso separado en el proceso de compilación. En terminos simples, un Preprocesador C es solo una herramienta de sustitución de texto y le da instrucciones al compilador para hacer el pre-procesamiento requerido antes de la verdadera compilación. Nos referiremos al Preprocesado de C como CPP. 

Todos los comandos del preprocesador empiezan con un un símbolo almohadilla (#). El primer carácter no puede ser uno en blanco y por temas de legibilidad, una directiva preprocesado debe empezar en la primera columna. La siguiente lista muestra todas las directivas importantes de preprocesado. 

| Nº | Directiva | Descripción                                                        |
|----+-----------+--------------------------------------------------------------------|
|  1 | #define   | Sustituye un preprocesador macro                                   |
|  2 | #include  | Inserta una cabera particular desde otro archivo                   |
|  3 | #undef    | No define un preprocesador macro                                   |
|  4 | #ifdef    | Devuelve verdadera si la macro está definida                       |
|  5 | #ifndef   | Devuelve verdadero si la macro no está definida                    |
|  6 | #if       | Prueba si una condición en tiempo de compilacón es verdadera       |
|  7 | #else     | La alternativa de #if                                              |
|  8 | #elif     | #else e #if en una sola sentencia                                  |
|  9 | #endif    | Finaliza el preprocesador condicional                              |
| 10 | #error    | Escribe un mensaje de error  en stderr                             |
| 11 | #pragma   | Emite un comando especial al compilador, usando un método estándar |


** Ejemplo de preprocesadores 

Analicemos los siguientes ejemplos para entender varias directivas 

: #define MAX_ARRAY_LENGTH 20

Esta driectiva le dice a CPP a reemplazar la instancia de MAX_ARRAY_LENGTH con 20. Usando #define para constatar el incremento de legibilidad. 

: #include <stdio.h>
: #include "myheader.h"

Esas directivas le dicen al CPP que obtengan stdio.h desde el *sistema de bibliotecas* y añada el tecto al actual archivo fuente. La siguietne línea le dice al CPP que obtenga *myheader.h* desde el directorio local y añada el contenido al actual fichero fuente. 

: #undef FILE_SIZE
: #define FILE_SIZE 42

Esto le dice al CPP que no defina la existente FILE_SIZE y lo defina como 42

#+BEGIN_SRC C
#ifndef  MESSAGE
#define MESSAGE "Lo que desees!"
#endif

#+END_SRC

Esto le dice al CPP que defina MESSAGE solo si MESSAGE no está ya definido 

#+BEGIN_SRC C
#ifdef DEBUG
/* tu declaración de debug */
#endif

#+END_SRC

Esto le dice al CPP que procese la declaracióń encerrada en if DEBUG está definido. Esto es útil si pasamos la bandera -DDEBUG al compilador gcc en tiempo de compilación. Esto definirá DEBUG, así podemos cambiar el debugging en on u off durante la compilación.

** Macros Predefinidas

ANSI C define un número de macros. Aunque cada uno está disponible para su uso en programación, las macros predefinidas no debería ser directamente modificadas. 

| Nº | Macro    | Descripción                                                       |
|  1 | \_DATE\_ | Fecha actual en formato "MMM DD YYYY "                            |
|  2 | \_TIME\_ | Hora actual en formato "HH:MM:SS"                                 |
|  3 | \_FILE\_ | Contiene el archivo actual como una cadena literal                |
|  4 | \_LINE\_ | Contiene el número de línea actual como una constante decimal     |
|  5 | \_STDC\_ | Definido como 1 cuando el compilador compila con el ANSI estándar |


Veamos los siguiente ejemplos: 

#+BEGIN_SRC C

  #include <stdio.h>

  int main(){

    printf("Archivo: %s\n", __FILE__);
    printf("Fecha: %s\n", __DATE__);
    printf("Hora: %s\n", __TIME__);
    printf("Línea: %d\n", __LINE__);
    printf("ANSI: %d\n", __STDC__);

  }

#+END_SRC


Cuando el código anterior en un archivo llamado *test.c* sea compilado y ejecutado producirá el siguiente resultado 

: Archivo: test.c
: Fecha: May 18 2020
: Hora: 18:34:25
: Línea: 8
: ANSI: 1 

** Operadores de preprocesamiento 

El preprocesador en C ofrece los siguiente operadores para ayudar a crear macros - 

*** El operador de macro continuación (\)

Un macro es normalmente confinado a una sola línea. El operador de macro continuación es usado para continuar un macro más allá de una simple línea. Por ejemplo - 

#+BEGIN_SRC C

  #define message_for(a, b)			\
    printf(#a " y " #b ":Te queremos!\n")

#+END_SRC

*** El operador (#) que pasa a cadenas

El operador #, cuando es usado en una definición de macro, convierte una parámetro de macro en una cadena de texto constante. Este operador puede ser usado solo en un macro teniendo un argumento específico o lista de parámetros. Por ejemplo - 

#+BEGIN_SRC C

  #include <stdio.h>

  #define message_for(a, b)			\
    printf(#a " y " #b ":Te queremos!\n")

  int main(void){
    message_for(Carole, Debra);
    return 0;
  }

#+END_SRC

Cuando compile y ejecute el código anterior, producirá el siguiente resultado - 

: Carole y Debra: Te queremos!

*** El operador (##) 

El operador (##) con una definición de macro combina dos argumentos. Esto permite que dos tokens separados en la definición de macro sean unidas en un solo token. Por ejemplo - 

#+BEGIN_SRC C

  #include <stdio.h>

  #define tokenpaster(n) printf("token" #n "= %d", token#n)

  int main(void){
    int token34 = 40;
    tokenpaster(34);
    return 0;
  }

#+END_SRC

Cuando el código anterior sea compilado y ejecutado, producirá el siguiente resultado - 

: token34 = 40

Ocurre así porque este ejemplo resulta en la siguiente verdadera salida desde el preprocesado - 

: printf ("token34 = %d", token34);

Este ejemplo muestra como la concatenación del token ##n en el token34 y aquí hemos usado ambos *stringsize* y *token-pasting*. 

*** El operador Defined()

El operador de preprocesado *defined* es usado en expresiones constantes para determinar si un identificador es definido usando #define. Si el identificador especificado es definido, el valor es verdadero (no-cero). Si el símbolo no es definido, el valor es falso (cero). El operador definido es especificado como sigue - 


#+BEGIN_SRC C

  #include <stdio.h>

  #if !define (MESSAGE)
  #define MESSAGE "Lo que desees!"
  #endif

  int main(void){
    printf("Este es el mensaje: %s\n", MESSAGE);
    return 0;
  }

#+END_SRC

Cuando compiles el código anterior y lo ejecutes, producirá el siguiente resultado - 

: Este es el mensaje: Lo que desees!

** Macros parametrizada 

Una de las más poderosas funciones del CPP es la habilidad de simular funciones usando macros parametrizada. Por ejemplo, podemos tener algún código para sacar el cuadrado de un número de la siguiente manera - 

#+BEGIN_SRC C

  int cuadrado(int x){
    return x * x;
  }

#+END_SRC

Podemos reescribir el código anterior usando una macro - 

: #define square(x) ((x) * (x))

Los macros con argumentos deben ser definidos usando la directiva *#define* antes de poder ser usadas. La lista de argumentos está encerrada en paréntesis y debe seguir inmediatamente del nombre del macro. Los espacios no están permitidos entre el nombre del macro y el paréntesis. Por ejemplo - 

#+BEGIN_SRC C

  #include <stdio.h>

  #define MAX(x,y) ((x) > (y) ? (x) : (y))

  int main(void){
    pirntf("El máximo entre 20 y 10 es %d\n", MAX(10, 20));
    return 0;
  }

#+END_SRC

Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado  -

: El máximo entre 20 y 10 es 20

* C - Archivos de cabecera

Un fichero de cabecera es un archivo con extensión *.h* que contiene declaraciones de funciones de C y definiciones de macros para ser compartidas entre varios archivos. Hay dos tipos de ficheros de cabecera; lo archivos que los programadores escriben y los que vienen con el compilador. 

La petición de uso de un archivo de cabecera en el nuestro programa por inclusión de la directiva de preprocesado *#include*, como hemos visto la inclusión del archivo de cabecera  *stdio.h*, el cual viene con el compilador. 

Incluir un archivo de cabecera es igual a copiar el contenido del archivo pero no lo hacemos porque causaría un error y no es una buena idea copiar el contenido de un archivo de cabecera en los archivos fuente, especialmente si hay varios archivos en un programa. 

Una simple práctica en los programas de C o C++ es que se mantengan todas las constantes, macros, variables globales del sistema y funciones prototipo en los archivos de cabecera e incluirlos donde sea que sean requeridos. 

** Sintaxis Include 

Tanto las cabeceras del sistema como las del usuario son incluidas usando la directiva *#include*. Se hace siguiendo dos formas -

: #include <file>

Esta forma es usada para las cabeceras del sistema. Esto buscará el nombre del archivo en la lista estándar del sistema de directorios. Podemos añadir directorios a esta lista con la opción -I mientras se compila el código fuente. 

: #include "file"

Esta forma es usada para las cabeceras de tu propio programa. Esto buscará el archivo del nombre dado en el directorio donde se encuentre el mismo archivo. Podemos añadir directorios a esta lista con la opción -I mientras se compila el código fuente.

** Operación Include 

La directiva *#include* funciona direccionando la directiva de preprocesado escaneando el archivo especificado como entrada antes de continuar con el resto del archivo fuente. La salida desde el preprocesado contiene la salida generada, seguido de la salida del resultado desde el archivo incluido, seguido de la salida que viene desde el texto después de la directiva *#include*. Por ejemplo, si tenemos el siguiente archivo de cabecera header.h - 

: char *test (void);

Y un un programa principal llamado program.c que usa el fichero de cabecera, como esto - 

#+BEGIN_SRC C

  int x;
  #include "header.h"

  int main(void){
    puts (test());
  }

#+END_SRC

el compilador verá el token de flujo como si el programa program.c leyera 

#+BEGIN_SRC C

  int x;
  char *test (void);

  int main(void){
    puts (test());
  }

#+END_SRC

** Cabeceras de un solo uso

Si una cabecera se intenta ser incluida dos veces, el compilador procesará su contenido dos veces y devolverá un error. La forma estándar para prevenir esto es encerrar el contenido real en un condicional de la siguiente manera - 

#+BEGIN_SRC C

  #ifndef HEADER_FILE
  #define HEADER_FILE

  La cabecera entera

  #endif


#+END_SRC

Esta construcción es comúnmente conocida como un envoltura *#ifndef*. Cuando la cabecera es incluída de nuevo, el condicional será falso, porque el HEADER_FILE es definido. El preprocesador saltará el contenido de este archivo, y así evitará el error. 

** Includes computados 

Algunas veces es necesario seleccionar uno de varias cabeceras diferentes para ser incluídas en nuestro programa. Para instanciar, se podría especificar los parámetros de configuración que deben ser usados en diferenntes momentos del sistema operativo. Se podrían añadir una serie de condicionales de la forma que sigue - 

#+BEGIN_SRC C

  #if SYSTEM_1
  # include "system_1.h"
  #elif SYSTEM_2
  # include "system_2.h"
  #elif SYSTEM_3
  ...
  #endif

#+END_SRC

Pero si esto crece, se vuelve tedioso, en vez de eso el preprocesador ofrece la habilidad de usar una macro para los nombres de las cabeceras. Esto es llamado *include computado*. En vez de escribir un nombre de cabecera como el argumento directo de *#include*, simplemente se pone un nombre de macro - 

#+BEGIN_SRC C
#define SYSTEM_H "system_1.h"
...
#include SYSTEM_H

#+END_SRC

SYSTEM_H será expandido, y el preprocesador buscará por system_1.h como si el *#include* hubiera sido escrito de la forma original. SYSTEM_H podría ser definido por su Makefile con una opción -D. 

* C - Conversión de tipos

Convertir un tipo de dato en otro es conocido como un tipo conversión. Por ejemplo, si queremos guardar un valor 'long' en un simple entero entonces pueden convertir 'long'en 'int'. Podemos convertir los valores desde un tipo a otro explicitamente usando los *operadores de conversión* de la siguiente manera - 

: (type_name) expression

Consideremos el siguiente ejemplo donde el operador de conversión causa la división de una variable entera en otra por la operación de punto-flotante. 

#+BEGIN_SRC C

  #include <stdio.h>

  main(){

    int suma = 17, conteo = 5;
    double media;

    media = (double) suam / conteo;
    printf("El valor de la media: %f\n", media);

  }


#+END_SRC 

Cuando el código anterior es compìlado y ejecutado, produce el siguiente resultado - 

: El valor de la media: 3.40000

Se puede ver que la operación de conversión ha precedido sobre la división, así el valor de la suma es primero convertido a *double* y finalmente se divide por el conteo que es un valor doble. 

La conversión de tipos puede ser implícito lo que es ejecutado por el compilador automaticamente, o puede ser especificado explícitamente a través del usod de los *operadores de conversón*. Es considerado una buena práctica de programación el usar la conversión de tipos cuando sea necesario.

** Promoción Entero

la promoción entero es el proceso por el cual los valores de los enteros tipo "más pequeños" que *int* o *unsigned int* son convertidos a *int* o *unsigned int*. Consideremos un ejemplo añadiendo un carácter con un entero - 

#+BEGIN_SRC C

  #include <stdio.h>

  main(){

    int i = 17;
    char c = 'c'; /* su ascii valor es 99 */ 
    int suma;

    suma = i + c;
    printf("El valor de la suma: %d\n", suma);

  }


#+END_SRC


Cuando el código anterior sea compilado y ejecutado, producirá el siguiente resultado - 

: El valor de la suam: 116

Aquí, el valor de la suma es 116 porque el compilador está convirtiendo el valor de 'c' a ASCII antes de hacer la suma. 


** Conversión artimética habitual

La *conversión aritmética habitual* es implícitamente desarrollada para convertir sus valores en un tipo común. El compilador primero hace la promoción a entero; si los operandos aún tienen diferentes tipos, son convertidos al tipo que aparece más alto en la siguiente jerarquía. 

# imagen 

La conversión habitual no funciona en operadores de asignación, u operadores lógicos como && o ||. Veamos el siguiente ejemplo para entender el concepto. 

#+BEGIN_SRC C

  #include <stdio.h>

  main(){

    int i = 17;
    char c = 'c'; /* el valor de en ascii es 99 */ 
    float suma;

    suma = i + c;
    printf("El valor de la suma: %f\n", suma);

  }


#+END_SRC


Cuando compilemos y ejecutemos el código anterior  producirá el siguiente resultado - 

: El valor de la suma: 116.0000000

Aquí, es simple de entender que primero c se convierte a entero, pero el valor final es doble, la conversión aritmética habitual aplicada y el compilador convierte i y c en 'float' y los añade al resultado en 'float' también. 


* C - Manejo de errores 

Como tal, C no proporciona soporte directo para el manejo de errores pero siendo un sistema de lenguaje de programación, proporciona acceso a bajo nivel en la forma de retorno de valores. Muchas de las funciones de C o incluso de Unix devuelven -1 o NULL en caso de cualquier error y establecen un error code *errno*. Esto es como una variable global e indica un error ocurrido durante la llamada a una función. Podemos encontrar varios códigos de error definidios en el fichero de cabecera <error.h>.

Así un programador de C puede comprobar los valores de retorno y tomar la acción apropiada dependiendo del valor devuelto. Es una buena práctica, establecer errno a 0 en el momento de inicializar un programa. Un valor de 0 indica que no hay errores en el programa. 

** errno, perror() y strerror()

C proporciona las funciones *perror()* y *strerror* las cuales pueden ser usadas para mostrar mensajes de texto asociados con *errno*. 

+ La función *perror()* muestra la cadena que le pasas, seguida de un punto y coma, un espacio, y entonces la representación textual del valor errno.

+ La función *strerror()*, devuelve un puntero a la representación textual del valor errno.

Vamos a simular una condición de error e intentar abrir un fichero el cual no existe.

#+BEGIN_SRC C
  #include <stdio.h>
  #include <errno.h>
  #include <string.h>

  extern int errno;

  int main() {

    FILE * pf;
    int errnum;
    pf = fopen ("unexist.txt", "rb");

    if (pf == NULL){

      errnum = errno;
      fprintf(stderr, "Valor de errno: %d\n", errno);
      perror("Error mostrado por perror");
      fprintf(stderr, "Error abriendo archivo: %s\n", strerror( errnum ));

    } else {

      fclose(pf);

    }

    return 0;

  }

#+END_SRC


Cuando el código anterior sea compilado y ejecutado, producirá el siguiente resultado - 

: Valor de errno: 2
: Error mostrado por perror: No such file or directory
: Error  abriendo archivo: No such file or directory

** Error de dividiro por cero

Es un problema común que a la hora de dividir cualquier número, los programadores no comprueban si el divisor es cero y finalmente crea un error en tiempo de ejecución.

El siguiente código arregla esto comprobando si el divisor es cero antes de dividir - 

#+BEGIN_SRC C

  #include <stdio.h>
  #include <stdlib.h> 

  main(){

    int dividendo = 20;
    int divisor = 0;
    int cociente;

    if (divisor == 0){
      fprintf(stderr, "División por cero! Saliendo...\n");
      exit(-1);
    }

    cociente = dividendo / divisor;
    fprintf(stderr, "El valor del cociente es: %d\n", cociente);

    exit(0);

  }


#+END_SRC


Cuando el código anterior sea compilado y ejecutado, producirá el siguiente resultado - 

: División por cero! Saliendo...

** Programa estatus salida 

Es una práctica común salir con un valor de EXIT_SUCCESS en caso de que el programa venga después de una operación exitosa. Aquí, EXIT_SUCCESS es un macro y es definida como 0.

Si tenemos una condición error en nuestro programa y venimos de ahí podemos salir con un estado EXIT_FAILURE el cual es definido como -1. Así vamos a escribir el siguiente  programa - 

#+BEGIN_SRC C

  #include <stdio.h>
  #include <stdlib.h>

  main(){

    int dividendo = 20;
    int divisor = 5;
    int cociente;

    if( divisor == 0) {
      fprintf(stderr, "División por cero! Saliendo...\n");
      exit(EXIT_FAILURE);
    }

    cociente = dividendo / divisor;
    fprintf(stderr, "Valor del cociente: %d\n", cociente);

    exit(EXIT_SUCCESS);

  }

#+END_SRC

Cuando compilemos y ejecutemos el código anterior, producirá el siguiente resultado - 

: Valor del cociente: 4


